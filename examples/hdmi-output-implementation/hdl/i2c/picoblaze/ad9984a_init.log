KCPSM6 Assembler log file for program 'E:\HDMI_FIFO_Testv03\hdl\i2c\picoblaze\ad9984a_init.psm'.
Generated by KCPSM6 version v2.63
Ken Chapman - Xilinx Ltd - 20th December 2013

Assembly datestamp: 05 Aug 2014
Assembly timestamp: 18:50:23

Contents
  Assembly listing
  List of PSM files
  List of CONSTANTs
  List of TABLEs
  List of STRINGs
  List of line labels
  Instruction usage statistics


Last occupied address: 0EC hex
Nominal program memory size: 1K (1024)   address(9:0)
Actual memory size: 4096
  (Default memory size)
Occupied memory locations: 237
Memory locations available: 3859


Assembly listing

 Addr Code                      Instruction

 000                            ;CONSTANT AD9984A_ADDRESS, 4C  ;May need to uncomment this
 000                            NAMEREG s6, i2c_reg_adr
 000                            NAMEREG s7, i2c_reg_data
 000                            NAMEREG s8, AD9984A_ADDRESS       ; May need to comment this line
 000                     start: ;JUMP start
 000                            ; Slight delay for startup
 000  20090                     CALL 090[delay_20ms]
 001  20090                     CALL 090[delay_20ms]
 002  2009E                     CALL 09E[I2C_initialise]
 003  0184C                     LOAD s8[AD9984A_ADDRESS], 4C      ; May need to comment this line
 004  20006                     CALL 006[AD9984A_init]
 005                   forever: 
 005                            ;CALL pcf8574a_led_test
 005  22005                     JUMP 005[forever]
 006              AD9984A_init: 
 006                            ;--------------------------------
 006                            ; Input and Output Configuration
 006                            ;--------------------------------
 006                            ; 0x1E: Input select=0, PWRDWN Polarity to 1 (+) instead of (-) hence B4 instead of B0
 006  0161E                     LOAD s6[i2c_reg_adr], 1E
 007  017B4                     LOAD s7[i2c_reg_data], B4
 008  2006A                     CALL 06A[i2c_write_AD9984A]
 009                            ; 0x1F: Output Sel 1
 009  0161F                     LOAD s6[i2c_reg_adr], 1F
 00A  01794                     LOAD s7[i2c_reg_data], 94
 00B  2006A                     CALL 06A[i2c_write_AD9984A]
 00C                            ; 0x20: Output Sel 2 #Enabled Filter with 0x07 [alt: 0x05]
 00C  01620                     LOAD s6[i2c_reg_adr], 20
 00D  01707                     LOAD s7[i2c_reg_data], 07
 00E  2006A                     CALL 06A[i2c_write_AD9984A]
 00F                            ;-----------------
 00F                            ; Analog settings
 00F                            ;-----------------
 00F                            ; 0x05: red gain[8:2]
 00F  01605                     LOAD s6[i2c_reg_adr], 05
 010  01740                     LOAD s7[i2c_reg_data], 40
 011  2006A                     CALL 06A[i2c_write_AD9984A]
 012                            ; 0x06: red gain[1:0]
 012  01606                     LOAD s6[i2c_reg_adr], 06
 013  01700                     LOAD s7[i2c_reg_data], 00
 014  2006A                     CALL 06A[i2c_write_AD9984A]
 015                            ; 0x07: grn gain[8:2]
 015  01607                     LOAD s6[i2c_reg_adr], 07
 016  01740                     LOAD s7[i2c_reg_data], 40
 017  2006A                     CALL 06A[i2c_write_AD9984A]
 018                            ; 0x08: grn gain[1:0]
 018  01608                     LOAD s6[i2c_reg_adr], 08
 019  01700                     LOAD s7[i2c_reg_data], 00
 01A  2006A                     CALL 06A[i2c_write_AD9984A]
 01B                            ; 0x09: blu gain[8:2]
 01B  01609                     LOAD s6[i2c_reg_adr], 09
 01C  01740                     LOAD s7[i2c_reg_data], 40
 01D  2006A                     CALL 06A[i2c_write_AD9984A]
 01E                            ; 0x0A: blu gain[1:0]
 01E  0160A                     LOAD s6[i2c_reg_adr], 0A
 01F  01700                     LOAD s7[i2c_reg_data], 00
 020  2006A                     CALL 06A[i2c_write_AD9984A]
 021                            ; 0x0B: red offset[10:3] #[Alt: 0x00]
 021  0160B                     LOAD s6[i2c_reg_adr], 0B
 022  017FF                     LOAD s7[i2c_reg_data], FF
 023  2006A                     CALL 06A[i2c_write_AD9984A]
 024                            ; 0x0C: red offset[2:0] #[Alt: 0x80]
 024  0160C                     LOAD s6[i2c_reg_adr], 0C
 025  017FF                     LOAD s7[i2c_reg_data], FF
 026  2006A                     CALL 06A[i2c_write_AD9984A]
 027                            ; 0x0D: grn offset[10:3] #[Alt: 0x00]
 027  0160D                     LOAD s6[i2c_reg_adr], 0D
 028  017FF                     LOAD s7[i2c_reg_data], FF
 029  2006A                     CALL 06A[i2c_write_AD9984A]
 02A                            ; 0x0E: grn offset[2:0] #[Alt: 0x80]
 02A  0160E                     LOAD s6[i2c_reg_adr], 0E
 02B  017FF                     LOAD s7[i2c_reg_data], FF
 02C  2006A                     CALL 06A[i2c_write_AD9984A]
 02D                            ; 0x0F: blu offset[10:3] #[Alt: 0x00]
 02D  0160F                     LOAD s6[i2c_reg_adr], 0F
 02E  017FF                     LOAD s7[i2c_reg_data], FF
 02F  2006A                     CALL 06A[i2c_write_AD9984A]
 030                            ; 0x10: blu offset[2:0] #[Alt: 0x80]
 030  01610                     LOAD s6[i2c_reg_adr], 10
 031  017FF                     LOAD s7[i2c_reg_data], FF
 032  2006A                     CALL 06A[i2c_write_AD9984A]
 033                            ; 0x1B: Clamp and offset, Turn on auto offset with 0x3B #Disable auto-offset with 0x1B [alt:0x2B]
 033  0161B                     LOAD s6[i2c_reg_adr], 1B
 034  0171B                     LOAD s7[i2c_reg_data], 1B
 035  2006A                     CALL 06A[i2c_write_AD9984A]
 036                            ; 0x3C: Auto Gain, Enable auto gain matching
 036  0163C                     LOAD s6[i2c_reg_adr], 3C
 037  0170E                     LOAD s7[i2c_reg_data], 0E
 038  2006A                     CALL 06A[i2c_write_AD9984A]
 039                            ;-------------------------------
 039                            ; Required Test Register Writes
 039                            ;-------------------------------
 039                            ; 0x2D:
 039  0162D                     LOAD s6[i2c_reg_adr], 2D
 03A  017E8                     LOAD s7[i2c_reg_data], E8
 03B  2006A                     CALL 06A[i2c_write_AD9984A]
 03C                            ; 0x2E:
 03C  0162E                     LOAD s6[i2c_reg_adr], 2E
 03D  017E0                     LOAD s7[i2c_reg_data], E0
 03E  2006A                     CALL 06A[i2c_write_AD9984A]
 03F                            ; 0x28:
 03F  01628                     LOAD s6[i2c_reg_adr], 28
 040  017BF                     LOAD s7[i2c_reg_data], BF
 041  2006A                     CALL 06A[i2c_write_AD9984A]
 042                            ; 0x29:
 042  01629                     LOAD s6[i2c_reg_adr], 29
 043  01702                     LOAD s7[i2c_reg_data], 02
 044  2006A                     CALL 06A[i2c_write_AD9984A]
 045                            ;-----------------
 045                            ; Timing Settings
 045                            ;-----------------
 045                            ; 0x01: PLLDIV[11:4]
 045  01601                     LOAD s6[i2c_reg_adr], 01
 046  01754                     LOAD s7[i2c_reg_data], 54
 047  2006A                     CALL 06A[i2c_write_AD9984A]
 048                            ; 0x02: PLLDIV[3:0]
 048  01602                     LOAD s6[i2c_reg_adr], 02
 049  01700                     LOAD s7[i2c_reg_data], 00
 04A  2006A                     CALL 06A[i2c_write_AD9984A]
 04B                            ; 0x03: VCO Ctrl
 04B  01603                     LOAD s6[i2c_reg_adr], 03
 04C  017A0                     LOAD s7[i2c_reg_data], A0
 04D  2006A                     CALL 06A[i2c_write_AD9984A]
 04E                            ; 0x04: Phase adjust
 04E  01604                     LOAD s6[i2c_reg_adr], 04
 04F  01780                     LOAD s7[i2c_reg_data], 80
 050  2006A                     CALL 06A[i2c_write_AD9984A]
 051                            ; 0x13: HS width = 136 pixel clks = 0x88
 051  01613                     LOAD s6[i2c_reg_adr], 13
 052  01788                     LOAD s7[i2c_reg_data], 88
 053  2006A                     CALL 06A[i2c_write_AD9984A]
 054                            ; 0x19: Clamp Placement [alt: 0x04]
 054  01619                     LOAD s6[i2c_reg_adr], 19
 055  01701                     LOAD s7[i2c_reg_data], 01
 056  2006A                     CALL 06A[i2c_write_AD9984A]
 057                            ; 0x1A: Clamp duration [alt: 0x82]
 057  0161A                     LOAD s6[i2c_reg_adr], 1A
 058  0178C                     LOAD s7[i2c_reg_data], 8C
 059  2006A                     CALL 06A[i2c_write_AD9984A]
 05A                            ;-----------------
 05A                            ; VSYNC Control
 05A                            ;-----------------
 05A                            ; 0x14: Enable VSYNC Filter
 05A  01614                     LOAD s6[i2c_reg_adr], 14
 05B  0171C                     LOAD s7[i2c_reg_data], 1C
 05C  2006A                     CALL 06A[i2c_write_AD9984A]
 05D                            ; 0x15: Set VSYNC duration to 6 HSYNCs
 05D  01615                     LOAD s6[i2c_reg_adr], 15
 05E  01706                     LOAD s7[i2c_reg_data], 06
 05F  2006A                     CALL 06A[i2c_write_AD9984A]
 060                            ; 0x16: Precoast
 060  01616                     LOAD s6[i2c_reg_adr], 16
 061  01703                     LOAD s7[i2c_reg_data], 03
 062  2006A                     CALL 06A[i2c_write_AD9984A]
 063                            ; 0x17: Postcoast
 063  01617                     LOAD s6[i2c_reg_adr], 17
 064  01706                     LOAD s7[i2c_reg_data], 06
 065  2006A                     CALL 06A[i2c_write_AD9984A]
 066                            ;-----------------
 066                            ; SOG Control
 066                            ;-----------------
 066                            ; 0x1D: Enable Raw HSYNCs on SOGOUT
 066  0161D                     LOAD s6[i2c_reg_adr], 1D
 067  0177D                     LOAD s7[i2c_reg_data], 7D
 068  2006A                     CALL 06A[i2c_write_AD9984A]
 069                            ;All Done! Now return to calling part
 069  25000                     RETURN 
 06A         i2c_write_AD9984A: 
 06A                            ; I2C START Signal
 06A  200A2                     CALL 0A2[I2C_start]
 06B                            ; I2C Write device address with write-bit(LSB=0) set
 06B  00580                     LOAD s5, s8[AD9984A_ADDRESS]      ;7-bit I2C device address of AD9984A
 06C  14506                     SL0 s5                            ;Write operation signified by LSB = 0
 06D  200AF                     CALL 0AF[I2C_Tx_byte]
 06E  200C6                     CALL 0C6[I2C_Rx_ACK]
 06F                            ; Write AD9984A Register Address
 06F  00560                     LOAD s5, s6[i2c_reg_adr]
 070  200AF                     CALL 0AF[I2C_Tx_byte]
 071  200C6                     CALL 0C6[I2C_Rx_ACK]
 072                            ; Write AD9984A Register Data
 072  00570                     LOAD s5, s7[i2c_reg_data]
 073  200AF                     CALL 0AF[I2C_Tx_byte]
 074  200C6                     CALL 0C6[I2C_Rx_ACK]
 075                            ; I2C STOP Signal
 075  200A9                     CALL 0A9[I2C_stop]
 076  25000                     RETURN 
 077         pcf8574a_led_test: 
 077  01838                     LOAD s8[AD9984A_ADDRESS], 38
 078  01600                     LOAD s6[i2c_reg_adr], 00
 079  017AA                     LOAD s7[i2c_reg_data], AA
 07A  2006A                     CALL 06A[i2c_write_AD9984A]
 07B  01839                     LOAD s8[AD9984A_ADDRESS], 39
 07C  01600                     LOAD s6[i2c_reg_adr], 00
 07D  01755                     LOAD s7[i2c_reg_data], 55
 07E  2006A                     CALL 06A[i2c_write_AD9984A]
 07F  20090                     CALL 090[delay_20ms]
 080  20090                     CALL 090[delay_20ms]
 081                            ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 081                            ; Now alternate LEDs
 081                            ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 081  01838                     LOAD s8[AD9984A_ADDRESS], 38
 082  01600                     LOAD s6[i2c_reg_adr], 00
 083  01755                     LOAD s7[i2c_reg_data], 55
 084  2006A                     CALL 06A[i2c_write_AD9984A]
 085  01839                     LOAD s8[AD9984A_ADDRESS], 39
 086  01600                     LOAD s6[i2c_reg_adr], 00
 087  017AA                     LOAD s7[i2c_reg_data], AA
 088  2006A                     CALL 06A[i2c_write_AD9984A]
 089  20090                     CALL 090[delay_20ms]
 08A  20090                     CALL 090[delay_20ms]
 08B  25000                     RETURN 
 08C                            INCLUDE "E:\HDMI_FIFO_Testv03\hdl\i2c\picoblaze\soft_delays_100mhz.psm"["soft_delays_100mhz.psm"]
 08C                            ;
 08C                            ;------------------------------------------------------------------------------------------
 08C                            ; Copyright © 2012-2013, Xilinx, Inc.
 08C                            ; This file contains confidential and proprietary information of Xilinx, Inc. and is
 08C                            ; protected under U.S. and international copyright and other intellectual property laws.
 08C                            ;------------------------------------------------------------------------------------------
 08C                            ;
 08C                            ; Disclaimer:
 08C                            ; This disclaimer is not a license and does not grant any rights to the materials
 08C                            ; distributed herewith. Except as otherwise provided in a valid license issued to
 08C                            ; you by Xilinx, and to the maximum extent permitted by applicable law: (1) THESE
 08C                            ; MATERIALS ARE MADE AVAILABLE "AS IS" AND WITH ALL FAULTS, AND XILINX HEREBY
 08C                            ; DISCLAIMS ALL WARRANTIES AND CONDITIONS, EXPRESS, IMPLIED, OR STATUTORY,
 08C                            ; INCLUDING BUT NOT LIMITED TO WARRANTIES OF MERCHANTABILITY, NON-INFRINGEMENT,
 08C                            ; OR FITNESS FOR ANY PARTICULAR PURPOSE; and (2) Xilinx shall not be liable
 08C                            ; (whether in contract or tort, including negligence, or under any other theory
 08C                            ; of liability) for any loss or damage of any kind or nature related to, arising
 08C                            ; under or in connection with these materials, including for any direct, or any
 08C                            ; indirect, special, incidental, or consequential loss or damage (including loss
 08C                            ; of data, profits, goodwill, or any type of loss or damage suffered as a result
 08C                            ; of any action brought by a third party) even if such damage or loss was
 08C                            ; reasonably foreseeable or Xilinx had been advised of the possibility of the same.
 08C                            ;
 08C                            ; CRITICAL APPLICATIONS
 08C                            ; Xilinx products are not designed or intended to be fail-safe, or for use in any
 08C                            ; application requiring fail-safe performance, such as life-support or safety
 08C                            ; devices or systems, Class III medical devices, nuclear facilities, applications
 08C                            ; related to the deployment of airbags, or any other applications that could lead
 08C                            ; to death, personal injury, or severe property or environmental damage
 08C                            ; (individually and collectively, "Critical Applications"). Customer assumes the
 08C                            ; sole risk and liability of any use of Xilinx products in Critical Applications,
 08C                            ; subject only to applicable laws and regulations governing limitations on product
 08C                            ; liability.
 08C                            ;
 08C                            ; THIS COPYRIGHT NOTICE AND DISCLAIMER MUST BE RETAINED AS PART OF THIS FILE AT ALL TIMES.
 08C                            ;
 08C                            ;------------------------------------------------------------------------------------------
 08C                            ;
 08C                            ;             _  ______ ____  ____  __  __  __
 08C                            ;            | |/ / ___|  _ \/ ___||  \/  |/ /_
 08C                            ;            | ' / |   | |_) \___ \| |\/| | '_ \
 08C                            ;            | . \ |___|  __/ ___) | |  | | (_) )
 08C                            ;            |_|\_\____|_|   |____/|_|  |_|\___/
 08C                            ;
 08C                            ;
 08C                            ;                PicoBlaze Reference Design.
 08C                            ;
 08C                            ;
 08C                            ; Ken Chapman - Xilinx Ltd
 08C                            ;
 08C                            ; 6th September 2012 - Initial version
 08C                            ;    18th March 2013 - Addition of 20ms delay
 08C                            ;
 08C                            ; This file contains routines that implement delays in software. It should be recognised
 08C                            ; that the delay periods are the result of executing instructions, and because every
 08C                            ; instruction takes 2 clock cycles to execute, it is possible to determine the exact
 08C                            ; delay period. However, besides the obvious dependency on the clock frequency, it
 08C                            ; should also be recognised that any interrupts to KCPSM6 (or use of sleep mode) will
 08C                            ; impact the timing. In general, it is better only to use soft delay routines in
 08C                            ; situations where approximate timing is adequate; in those situations KCPSM6 will often
 08C                            ; exceed your requirements.
 08C                            ;
 08C                            ;
 08C                            ;------------------------------------------------------------------------------------------
 08C                            ; Software Delays based on 100MHz clock
 08C                            ;------------------------------------------------------------------------------------------
 08C                            ;
 08C                            ; The number of iterations of a delay loop required to form each delay required are
 08C                            ; loaded into the register set [s2,s1,s0] and then the delay loop is started.
 08C                            ;
 08C                            ; Registers used s0, s1, s2
 08C                            ;
 08C                            ; 1ms is 10,000 x 100ns     (10,000 = 002710 hex)
 08C                            ;
 08C  01200          delay_1ms: LOAD s2, 00
 08D  01127                     LOAD s1, 27
 08E  01010                     LOAD s0, 10
 08F  22098                     JUMP 098[software_delay]
 090                            ;
 090                            ; 20ms is 200,000 x 100ns     (200,000 = 030D40 hex)
 090                            ;
 090  01203         delay_20ms: LOAD s2, 03
 091  0110D                     LOAD s1, 0D
 092  01040                     LOAD s0, 40
 093  22098                     JUMP 098[software_delay]
 094                            ;
 094                            ;
 094                            ; 1s is 10,000,000 x 100ns     (10,000,000 = 989680 hex)
 094                            ;
 094  01298           delay_1s: LOAD s2, 98
 095  01196                     LOAD s1, 96
 096  01080                     LOAD s0, 80
 097  22098                     JUMP 098[software_delay]
 098                            ;
 098                            ; The delay loop decrements [s2,s1,s0] until it reaches zero
 098                            ; Each decrement cycle is 5 instructions which is 10 clock cycles (100ns at 100MHz)
 098                            ;
 098  00000     software_delay: LOAD s0, s0                       ;pad loop to make it 10 clock cycles (5 instructions)
 099  19001                     SUB s0, 01[1'd]
 09A  1B100                     SUBCY s1, 00[0'd]
 09B  1B200                     SUBCY s2, 00[0'd]
 09C  36098                     JUMP NZ, 098[software_delay]
 09D  25000                     RETURN 
 09E                            ;
 09E                            ;
 09E                            ;------------------------------------------------------------------------------------------
 09E                            ; End of 'soft_delays_100mhz.psm'
 09E                            ;------------------------------------------------------------------------------------------
 09E                            ;
 09E                            INCLUDE "E:\HDMI_FIFO_Testv03\hdl\i2c\picoblaze\i2c_routines.psm"["i2c_routines.psm"]
 09E                            ;
 09E                            ;------------------------------------------------------------------------------------------
 09E                            ; Copyright © 2011-2012, Xilinx, Inc.
 09E                            ; This file contains confidential and proprietary information of Xilinx, Inc. and is
 09E                            ; protected under U.S. and international copyright and other intellectual property laws.
 09E                            ;------------------------------------------------------------------------------------------
 09E                            ;
 09E                            ; Disclaimer:
 09E                            ; This disclaimer is not a license and does not grant any rights to the materials
 09E                            ; distributed herewith. Except as otherwise provided in a valid license issued to
 09E                            ; you by Xilinx, and to the maximum extent permitted by applicable law: (1) THESE
 09E                            ; MATERIALS ARE MADE AVAILABLE "AS IS" AND WITH ALL FAULTS, AND XILINX HEREBY
 09E                            ; DISCLAIMS ALL WARRANTIES AND CONDITIONS, EXPRESS, IMPLIED, OR STATUTORY,
 09E                            ; INCLUDING BUT NOT LIMITED TO WARRANTIES OF MERCHANTABILITY, NON-INFRINGEMENT,
 09E                            ; OR FITNESS FOR ANY PARTICULAR PURPOSE; and (2) Xilinx shall not be liable
 09E                            ; (whether in contract or tort, including negligence, or under any other theory
 09E                            ; of liability) for any loss or damage of any kind or nature related to, arising
 09E                            ; under or in connection with these materials, including for any direct, or any
 09E                            ; indirect, special, incidental, or consequential loss or damage (including loss
 09E                            ; of data, profits, goodwill, or any type of loss or damage suffered as a result
 09E                            ; of any action brought by a third party) even if such damage or loss was
 09E                            ; reasonably foreseeable or Xilinx had been advised of the possibility of the same.
 09E                            ;
 09E                            ; CRITICAL APPLICATIONS
 09E                            ; Xilinx products are not designed or intended to be fail-safe, or for use in any
 09E                            ; application requiring fail-safe performance, such as life-support or safety
 09E                            ; devices or systems, Class III medical devices, nuclear facilities, applications
 09E                            ; related to the deployment of airbags, or any other applications that could lead
 09E                            ; to death, personal injury, or severe property or environmental damage
 09E                            ; (individually and collectively, "Critical Applications"). Customer assumes the
 09E                            ; sole risk and liability of any use of Xilinx products in Critical Applications,
 09E                            ; subject only to applicable laws and regulations governing limitations on product
 09E                            ; liability.
 09E                            ;
 09E                            ; THIS COPYRIGHT NOTICE AND DISCLAIMER MUST BE RETAINED AS PART OF THIS FILE AT ALL TIMES.
 09E                            ;
 09E                            ;------------------------------------------------------------------------------------------
 09E                            ;
 09E                            ;
 09E                            ;             _  ______ ____  ____  __  __  __
 09E                            ;            | |/ / ___|  _ \/ ___||  \/  |/ /_
 09E                            ;            | ' / |   | |_) \___ \| |\/| | '_ \
 09E                            ;            | . \ |___|  __/ ___) | |  | | (_) )
 09E                            ;            |_|\_\____|_|   |____/|_|  |_|\___/
 09E                            ;
 09E                            ;
 09E                            ;                PicoBlaze Reference Design.
 09E                            ;
 09E                            ;
 09E                            ; Routines for General Purpose I2C Communication
 09E                            ;
 09E                            ; Ken Chapman - Xilinx Ltd
 09E                            ;
 09E                            ; 9th March 2012 - Initial Version
 09E                            ; 12th October 2012 - Adjustments to values assigned to constant directives
 09E                            ; 16th October 2012 - Code optimisation (lowest level signal drive routines)
 09E                            ; 25th October 2012 - Correct definition of a binary value (functionally identical)
 09E                            ; 6th November 2012 - Correction to comment only
 09E                            ;
 09E                            ;
 09E                            ;     NOTE - This is not a standalone PSM file. Include this file in a program that
 09E                            ;            then calls these routines and works with the values in scratch pad memory.
 09E                            ;
 09E                            ;                INCLUDE "i2c_routines.psm"
 09E                            ;
 09E                            ;
 09E                            ;     IMPORTANT - These routines interact with input and output ports which must
 09E                            ;                 be appropriately defined to drive and read the physical I2C
 09E                            ;                 signals. Four CONSTANT directives must define values consistent
 09E                            ;                 with your port definitions and a further CONSTANT must be defined
 09E                            ;                 that is related to the frequency of the clock being applied to
 09E                            ;                 KCPSM6 in your design (Please see descriptions below).
 09E                            ;
 09E                            ;
 09E                            ; INTRODUCTION
 09E                            ; ------------
 09E                            ;
 09E                            ; The following routines implement an I2C 'Master' with a communication data rate
 09E                            ; approaching (but not exceeding) 100KHz. The I2C bus connects to the FPGA I/O
 09E                            ; pins which must in turn be connected to KCPSM6 input and output ports. Therefore
 09E                            ; your hardware design must be appropriate before these routines can be used and
 09E                            ; these routines need to know which ports you have allocated for I2C in your design.
 09E                            ;
 09E                            ; With the hardware in place, the routines provide the ability to perform each of the
 09E                            ; actions generally required for an I2C transaction including bus idle, Start (S),
 09E                            ; Repeated Start (Sr), Stop (P), Transmission of Acknowledge (ACK) or No Acknowledge
 09E                            ; (NACK), receiving and testing of Acknowledge (ACK) from a slave and of course the
 09E                            ; ability to transmit and receive bytes used for addressing, commands and data.
 09E                            ;
 09E                            ; It is assumed that you are familiar with I2C, so the descriptions contained in this
 09E                            ; file are concerned primarily with how KCPSM6 is used to implement the signaling and
 09E                            ; elements of the transactions rather than to teach I2C itself. In the end, it is the
 09E                            ; sequence in which these routines are invoked that will result in successful
 09E                            ; communication with a slave device and that requires an understanding of the needs
 09E                            ; of each particular slave to implement correctly (i.e. a study of data sheets for
 09E                            ; slave devices when writing higher level code).
 09E                            ;
 09E                            ; NOTE - As provided, these routines assume that KCPSM6 is the only I2C master connected
 09E                            ;        to the bus. A multiple master implementation would be possible but these routines
 09E                            ;        are not suitable in such arrangements.
 09E                            ;
 09E                            ;
 09E                            ;
 09E                            ; Code typical of an I2C write of data to a slave using the routines provided...
 09E                            ;
 09E                            ;    CALL I2C_initialise
 09E                            ;    CALL I2C_start
 09E                            ;    LOAD s5, slave_address       ;7-bit slave address
 09E                            ;    SL0 s5                       ;Write operation signified by LSB = 0
 09E                            ;    CALL I2C_Tx_byte
 09E                            ;    CALL I2C_Rx_ACK
 09E                            ;    JUMP C, communication_fail   ;did the slave respond?
 09E                            ;    LOAD s5, data_byte1
 09E                            ;    CALL I2C_Tx_byte
 09E                            ;    CALL I2C_Rx_ACK
 09E                            ;    LOAD s5, data_byte2
 09E                            ;    CALL I2C_Tx_byte
 09E                            ;    CALL I2C_Rx_ACK
 09E                            ;    CALL I2C_stop
 09E                            ;
 09E                            ;
 09E                            ; Code typical of an I2C read of data from a slave using the routines provided...
 09E                            ;
 09E                            ;    CALL I2C_initialise
 09E                            ;    CALL I2C_start
 09E                            ;    LOAD s5, slave_address       ;7-bit slave address
 09E                            ;    SL0 s5                       ;Write operation signified by LSB = 0
 09E                            ;    CALL I2C_Tx_byte
 09E                            ;    CALL I2C_Rx_ACK
 09E                            ;    JUMP C, communication_fail   ;did the slave respond?
 09E                            ;    LOAD s5, slave_command
 09E                            ;    CALL I2C_Tx_byte
 09E                            ;    CALL I2C_Rx_ACK
 09E                            ;    CALL I2C_start               ;bus restart (Sr)
 09E                            ;    LOAD s5, slave_address       ;7-bit slave address
 09E                            ;    SL1 s5                       ;Read operation signified by LSB = 1
 09E                            ;    CALL I2C_Tx_byte
 09E                            ;    CALL I2C_Rx_ACK
 09E                            ;    CALL I2C_Rx_byte
 09E                            ;    STORE s5, data1
 09E                            ;    CALL I2C_Tx_ACK
 09E                            ;    CALL I2C_Rx_byte
 09E                            ;    STORE s5, data2
 09E                            ;    CALL I2C_Tx_NACK             ;transmit NACK before Stop
 09E                            ;    CALL I2C_stop
 09E                            ;
 09E                            ;
 09E                            ;------------------------------------------------------------------------------------------
 09E                            ; Hardware
 09E                            ;------------------------------------------------------------------------------------------
 09E                            ;
 09E                            ; Clock
 09E                            ; -----
 09E                            ;
 09E                            ; All KCPSM6 instructions take 2 clock cycles to execute and it is this predictability
 09E                            ; that these routines exploit to ensure that the I2C communication rate does not exceed
 09E                            ; 100KHz. However, these routines will only implement the correct timing if something
 09E                            ; related to the frequency of the clock provide to KCPSM6 is known and the CONSTANT
 09E                            ; directive below must be defined correctly to achieve that.
 09E                            ;
 09E                            CONSTANT I2C_time_reference, 24'd
 09E                            ;
 09E                            ;  I2C_time_reference =  ( fclk - 6 ) / 4
 09E                            ;
 09E                            ;   Where...
 09E                            ;     'fclk' is the clock frequency applied to KCPSM6 in MHz.
 09E                            ;     Any non-integer result should be rounded up.
 09E                            ;     Typical values....
 09E                            ;
 09E                            ;          fclk (MHz)      I2C_time_reference
 09E                            ;            50                  11'd
 09E                            ;            80                  19'd
 09E                            ;           100                  24'd
 09E                            ;           200                  49'd
 09E                            ;
 09E                            ;
 09E                            ;
 09E                            ; I2C Bus and KCPSM6 ports
 09E                            ; ------------------------
 09E                            ;
 09E                            ; An I2C bus consists of two signals called 'CLK' and 'DATA' or something similar. Both
 09E                            ; signals need to be connected to the FPGA via 'open collector' style bidirectional I/O
 09E                            ; pins with a pull-up resistor (typically an external resistor but the built in pull-up
 09E                            ; resistor of the IOB may also be enabled in some cases). These I/O pins must then be
 09E                            ; connected to a KCPSM6 input port and KCPSM6 output port such that both signals can
 09E                            ; be both driven and read.
 09E                            ;
 09E                            ;  The input port used to read the logic levels on the CLK and DATA signals external
 09E                            ;  to the FPGA.
 09E                            ;
 09E                            ;  The output port is used to control the output drive of the CLK and DATA pins.
 09E                            ;    Since the pins are 'open collector' style then when KCPSM6 outputs...
 09E                            ;      '0' will result in the signal being driven Low.
 09E                            ;      '1' will result in the pin becoming tri-state (Z) so the signal will be pulled
 09E                            ;          High by the resistor or can be driven or held low by a slave device.
 09E                            ;
 09E                            ; In a typical VHDL based design the following snippets of code could be inserted at the
 09E                            ; appropriate places to define the I2C pins and connection to KCPSM6...
 09E                            ;
 09E                            ;   entity <name>
 09E                            ;   Port (   i2c_clk : inout std_logic;
 09E                            ;           i2c_data : inout std_logic;
 09E                            ;
 09E                            ;
 09E                            ;   signal  drive_i2c_clk : std_logic;
 09E                            ;   signal drive_i2c_data : std_logic;
 09E                            ;
 09E                            ;
 09E                            ;   i2c_clk  <= '0' when drive_i2c_clk = '0' else 'Z';
 09E                            ;   i2c_data <= '0' when drive_i2c_data = '0' else 'Z';
 09E                            ;
 09E                            ;
 09E                            ;   input_ports: process(clk)
 09E                            ;   begin
 09E                            ;     if clk'event and clk = '1' then
 09E                            ;       case port_id(1 downto 0) is
 09E                            ;
 09E                            ;         -- Read I2C Bus at port address 02 hex
 09E                            ;         when "10" =>    in_port(0) <= i2c_clk;
 09E                            ;                         in_port(1) <= i2c_data;
 09E                            ;
 09E                            ;
 09E                            ;   output_ports: process(clk)
 09E                            ;   begin
 09E                            ;     if clk'event and clk = '1' then
 09E                            ;       if write_strobe = '1' then
 09E                            ;
 09E                            ;         -- Write to I2C Bus at port address 08 hex
 09E                            ;         if port_id(3) = '1' then
 09E                            ;           drive_i2c_clk <= out_port(0);
 09E                            ;           drive_i2c_data <= out_port(1);
 09E                            ;         end if;
 09E                            ;
 09E                            ;
 09E                            ;
 09E                            ; To correspond with the definition of the input and output ports, the four CONSTANT
 09E                            ; directives below must be set correctly before these I2C routines are used. The
 09E                            ; values shown below correspond with the VHDL snippets above.
 09E                            ;
 09E                            CONSTANT I2C_input_port, 02       ;port address of I2C input port
 09E                            CONSTANT I2C_output_port, 08      ;port address of I2C output port
 09E                            ;
 09E                            CONSTANT I2C_clk, 00000001'b      ;Bit to which CLK is assigned on both ports
 09E                            CONSTANT I2C_data, 00000010'b     ;Bit to which DATA is assigned on both ports
 09E                            ;
 09E                            ;
 09E                            ;------------------------------------------------------------------------------------------
 09E                            ; Registers
 09E                            ;------------------------------------------------------------------------------------------
 09E                            ;
 09E                            ; The following registers within the currently active bank are used by these routines....
 09E                            ;
 09E                            ;    s0, s1, s5 and sF
 09E                            ;
 09E                            ;
 09E                            ; IMPORTANT - Register 'sF' is used to control and remember the drive values of the CLK
 09E                            ;             and DATA signals so its contents MUST NOT be altered between calls to the
 09E                            ;             various routines used to construct a complete I2C transaction. The routine
 09E                            ;             called 'I2C_initialise' is typically used before starting any transaction
 09E                            ;             as it will initialise 'sF' as well as the actual I2C interface.
 09E                            ;
 09E                            ;
 09E                            ;------------------------------------------------------------------------------------------
 09E                            ; Routine to initialise the CLK and DATA signals (and 'sF')
 09E                            ;------------------------------------------------------------------------------------------
 09E                            ;
 09E                            ; Places CLK and DATA into tri-state (Z) so that both lines reach idle High level.
 09E                            ; This also initialises register sF ready for other routines forming a transaction.
 09E                            ;
 09E                            ; This routine MUST be used before starting the first I2C transaction and before any
 09E                            ; further transaction if the contents of register 'sF' have been compromised since the
 09E                            ; end of the last I2C transaction.
 09E                            ;
 09E  01F01     I2C_initialise: LOAD sF, 01[I2C_clk]              ;CLK = Z
 09F  05F02                     OR sF, 02[I2C_data]               ;DATA = Z
 0A0  2DF08                     OUTPUT sF, 08[I2C_output_port]
 0A1  25000                     RETURN 
 0A2                            ;
 0A2                            ;
 0A2                            ;------------------------------------------------------------------------------------------
 0A2                            ; Routine issue an I2C Start (S) or Repeated Start (Sr) condition.
 0A2                            ;------------------------------------------------------------------------------------------
 0A2                            ;
 0A2                            ; Used to begin any I2C transaction or performed during a transaction when changing the
 0A2                            ; from an write to a read.
 0A2                            ;
 0A2                            ; The Start (S) or Repeated Start (Sr) condition is signified by a High to Low transition
 0A2                            ; of the DATA line whilst the CLK line is High.
 0A2                            ;
 0A2  200D6          I2C_start: CALL 0D6[I2C_data_Z]              ;DATA = Z (High)
 0A3  200CD                     CALL 0CD[I2C_clk_Z]               ;CLK = Z (waits until definitely High)
 0A4  200E3                     CALL 0E3[I2C_delay_5us]           ;delay before start (S)
 0A5  200D3                     CALL 0D3[I2C_data_Low]            ;High to How transition on DATA whilst CLK is High
 0A6  200E4                     CALL 0E4[I2C_delay_4us]
 0A7  200C9                     CALL 0C9[I2C_clk_Low]             ;CLK = 0 (plus 5us delay)
 0A8  25000                     RETURN 
 0A9                            ;
 0A9                            ;
 0A9                            ;------------------------------------------------------------------------------------------
 0A9                            ; Routine issue an I2C Stop (P) condition
 0A9                            ;------------------------------------------------------------------------------------------
 0A9                            ;
 0A9                            ; Used to end any I2C transaction.
 0A9                            ;
 0A9                            ; The Stop (S) condition is signified by a Low to High transition of the DATA line whilst
 0A9                            ; the CLK line is High.
 0A9                            ;
 0A9                            ; Note that following this routine the CARRY flag is '0' and can be used to confirm a
 0A9                            ; good I2C communication (see 'I2C_Rx_ACK' routine).
 0A9                            ;
 0A9  200D3           I2C_stop: CALL 0D3[I2C_data_Low]            ;DATA = 0
 0AA  200E3                     CALL 0E3[I2C_delay_5us]
 0AB  200CD                     CALL 0CD[I2C_clk_Z]               ;CLK = Z (waits until definitely High)
 0AC  200E4                     CALL 0E4[I2C_delay_4us]
 0AD  200D6                     CALL 0D6[I2C_data_Z]              ;DATA = Z (High)
 0AE  25000                     RETURN 
 0AF                            ;
 0AF                            ;
 0AF                            ;------------------------------------------------------------------------------------------
 0AF                            ; Routine to transmit one byte from the KCPSM6 master to a slave
 0AF                            ;------------------------------------------------------------------------------------------
 0AF                            ;
 0AF                            ; The byte to be transmitted must be provided in register 's5'.
 0AF                            ;
 0AF                            ; The byte is transmitted most significant bit (MSB) first. As each of the 8 bits are
 0AF                            ; presented to the DATA line the CLK line is pulsed High.
 0AF                            ;
 0AF  01180        I2C_Tx_byte: LOAD s1, 80[10000000'b]           ;8-bits to transmit starting with MSB
 0B0  0C510    I2C_Tx_next_bit: TEST s5, s1                       ;test data bit for High or Low
 0B1  360B4                     JUMP NZ, 0B4[I2C_Tx1]
 0B2  200D3                     CALL 0D3[I2C_data_Low]            ;DATA = 0
 0B3  220B5                     JUMP 0B5[I2C_Tx_tsu]
 0B4  200D6            I2C_Tx1: CALL 0D6[I2C_data_Z]              ;DATA = Z (High)
 0B5  200BF         I2C_Tx_tsu: CALL 0BF[I2C_clk_pulse]           ;generate clock pulse with delays
 0B6  1410E                     SR0 s1                            ;move to next bit
 0B7  39000                     RETURN C                          ;have 8 bits been transmitted?
 0B8  220B0                     JUMP 0B0[I2C_Tx_next_bit]
 0B9                            ;
 0B9                            ;
 0B9                            ;------------------------------------------------------------------------------------------
 0B9                            ; Routine to receive one byte from a slave
 0B9                            ;------------------------------------------------------------------------------------------
 0B9                            ;
 0B9                            ; The byte received will be returned in register 's5'.
 0B9                            ;
 0B9                            ; The byte is received most significant bit (MSB) first. Each  of the 8 bits are sampled
 0B9                            ; as the CLK line is pulsed High.
 0B9                            ;
 0B9  01108        I2C_Rx_byte: LOAD s1, 08[8'd]                  ;8-bits to receive
 0BA  200D9    I2C_Rx_next_bit: CALL 0D9[I2C_Rx_bit]              ;receive and shift bit into LSB of s5
 0BB  19101                     SUB s1, 01[1'd]                   ;count bits received
 0BC  360BA                     JUMP NZ, 0BA[I2C_Rx_next_bit]
 0BD  25000                     RETURN 
 0BE                            ;
 0BE                            ;
 0BE                            ;------------------------------------------------------------------------------------------
 0BE                            ; Routine to transmit Acknowledge (ACK) from KCPSM6 master to a slave
 0BE                            ;------------------------------------------------------------------------------------------
 0BE                            ;
 0BE                            ; An Acknowledge (ACK) bit is transmitted to a slave after receiving a byte of data.
 0BE                            ;
 0BE                            ; ACK is simply the transmission of a '0' requiring the DATA line to be driven Low whilst
 0BE                            ; the CLK line is pulsed High.
 0BE                            ;
 0BE  200D3         I2C_Tx_ACK: CALL 0D3[I2C_data_Low]            ;DATA = 0
 0BF                            ;
 0BF  200E3      I2C_clk_pulse: CALL 0E3[I2C_delay_5us]
 0C0  200CD                     CALL 0CD[I2C_clk_Z]               ;CLK = Z (waits until definitely High)
 0C1  200E4                     CALL 0E4[I2C_delay_4us]           ;clock pulse width
 0C2  200C9                     CALL 0C9[I2C_clk_Low]             ;end of CLK clock pulse includes 5us delay
 0C3  25000                     RETURN 
 0C4                            ;
 0C4                            ;
 0C4                            ;------------------------------------------------------------------------------------------
 0C4                            ; Routine to transmit No Acknowledge (NACK) from KCPSM6 master to a slave
 0C4                            ;------------------------------------------------------------------------------------------
 0C4                            ;
 0C4                            ; A No Acknowledge (NACK) bit is transmitted to a slave after receiving a byte of data and
 0C4                            ; typically used to signify to a slave that a read transaction has been completed.
 0C4                            ;
 0C4                            ; NACK is simply the transmission of a '1' requiring the DATA line to be driven High
 0C4                            ; whilst the CLK line is pulsed High.
 0C4                            ;
 0C4  200D6        I2C_Tx_NACK: CALL 0D6[I2C_data_Z]              ;DATA = Z (High)
 0C5  220BF                     JUMP 0BF[I2C_clk_pulse]           ;generate clock pulse (includes return)
 0C6                            ;
 0C6                            ;
 0C6                            ;------------------------------------------------------------------------------------------
 0C6                            ; Routine to receive and test the Acknowledge (ACK) from a slave
 0C6                            ;------------------------------------------------------------------------------------------
 0C6                            ;
 0C6                            ; The KCPSM6 master will receive an Acknowledge (ACK) bit from a slave following the
 0C6                            ; transmitted of a byte to the slave. Receiving an ACK indicates that the slave responded
 0C6                            ; as expected but receiving a No Acknowledge (NACK) implies that something went wrong!
 0C6                            ;
 0C6                            ; The KCPSM6 master will pulse the CLK line High and receive the acknowledge bit from the
 0C6                            ; slave. The received ACK bit will be returned in the least significant bit (LSB) of the
 0C6                            ; 's5' register. Furthermore, a test will be performed such that the CARRY flag will also
 0C6                            ; reveal if the bit was ACK or NACK.
 0C6                            ;
 0C6                            ;     Received ACK bit    Meaning      CARRY(C)
 0C6                            ;           0              ACK           0
 0C6                            ;           1              NACK          1
 0C6                            ;
 0C6                            ; Note that following the 'I2C_stop' routine the CARRY flag is '0'.
 0C6                            ;
 0C6  200D9         I2C_Rx_ACK: CALL 0D9[I2C_Rx_bit]              ;receive ACK bit into LSB of s5
 0C7  0D501                     TEST s5, 01[00000001'b]           ;set flags
 0C8  25000                     RETURN 
 0C9                            ;
 0C9                            ;
 0C9                            ;------------------------------------------------------------------------------------------
 0C9                            ; Subroutines used by the main I2C routines above
 0C9                            ;------------------------------------------------------------------------------------------
 0C9                            ;
 0C9                            ; These routines actually control the I2C signals an ensure that timing specifications
 0C9                            ; consistent with maximum bit rate of 100KHz are not exceeded.
 0C9                            ;
 0C9                            ;
 0C9                            ; Drive CLK Low and wait for 5us before doing anything else.
 0C9                            ;
 0C9  03FFE        I2C_clk_Low: AND sF, FE[~I2C_clk]              ;CLK = 0
 0CA  2DF08                     OUTPUT sF, 08[I2C_output_port]
 0CB  200E3                     CALL 0E3[I2C_delay_5us]
 0CC  25000                     RETURN 
 0CD                            ;
 0CD                            ;
 0CD                            ; Place CLK into tri-state (Z) so that it can go High.
 0CD                            ; Then wait for CLK to actually become High before returning because a slave
 0CD                            ; has the ability to stretch a clock to slow communication down.
 0CD                            ;
 0CD  05F01          I2C_clk_Z: OR sF, 01[I2C_clk]                ;CLK = Z
 0CE  2DF08                     OUTPUT sF, 08[I2C_output_port]
 0CF  09002  I2C_wait_clk_High: INPUT s0, 02[I2C_input_port]      ;read external signals
 0D0  0D001                     TEST s0, 01[I2C_clk]              ;test CLK bit
 0D1  320CF                     JUMP Z, 0CF[I2C_wait_clk_High]    ;wait if CLK held Low by slave
 0D2  25000                     RETURN 
 0D3                            ;
 0D3                            ;
 0D3                            ; Drive DATA Low and wait for 5us before doing anything else.
 0D3                            ;
 0D3  03FFD       I2C_data_Low: AND sF, FD[~I2C_data]             ;DATA = 0
 0D4  2DF08                     OUTPUT sF, 08[I2C_output_port]
 0D5  25000                     RETURN 
 0D6                            ;
 0D6                            ;
 0D6                            ; Place DATA into tri-state (Z) so that it can go High.
 0D6                            ; This can be used to transmit or receive a '1' but can also be used by the
 0D6                            ; slave to return a '0' by holding the data line Low against the pull-up resistor.
 0D6                            ;
 0D6  05F02         I2C_data_Z: OR sF, 02[I2C_data]               ;DATA = Z
 0D7  2DF08                     OUTPUT sF, 08[I2C_output_port]
 0D8  25000                     RETURN 
 0D9                            ;
 0D9                            ;
 0D9                            ; Receive one bit of data
 0D9                            ;
 0D9                            ; The bit received is shifted into the LSB of register 's5'.
 0D9                            ;
 0D9                            ; This the routine must be executed from the condition CLK low.
 0D9                            ;
 0D9                            ; The DATA line is released to allow a slave to transmit. There will be a
 0D9                            ; 5us delay before the CLK is released to start a clock pulse. The start of
 0D9                            ; the clock pulse can be delayed by a slave but a High duration of 4us is
 0D9                            ; guaranteed. The value of the DATA line is sampled at the mid-point of the
 0D9                            ; 4us high period (i.e. after 2us). The CLK clock pulse is followed by a
 0D9                            ; delay of 5us before anything else can happen.
 0D9                            ;
 0D9  200D6         I2C_Rx_bit: CALL 0D6[I2C_data_Z]              ;DATA = Z (slave can now drive)
 0DA  200E3                     CALL 0E3[I2C_delay_5us]
 0DB  200CD                     CALL 0CD[I2C_clk_Z]               ;CLK = Z (waits until definitely High)
 0DC  200E6                     CALL 0E6[I2C_delay_2us]           ;middle of SCL clock pulse
 0DD  09002                     INPUT s0, 02[I2C_input_port]      ;read external signals
 0DE  0D002                     TEST s0, 02[I2C_data]             ;set carry flag with value of DATA
 0DF  14500                     SLA s5                            ;shift received bit into LSB of s5
 0E0  200E6                     CALL 0E6[I2C_delay_2us]           ;complete 4us SCL clock pulse
 0E1  200C9                     CALL 0C9[I2C_clk_Low]             ;end of clock pulse includes 5us delay
 0E2  25000                     RETURN 
 0E3                            ;
 0E3                            ;
 0E3                            ; Software Delays for I2C Signal Timing
 0E3                            ;
 0E3  200E9      I2C_delay_5us: CALL 0E9[I2C_delay_1us]
 0E4  200E9      I2C_delay_4us: CALL 0E9[I2C_delay_1us]
 0E5  200E9                     CALL 0E9[I2C_delay_1us]
 0E6  200E9      I2C_delay_2us: CALL 0E9[I2C_delay_1us]
 0E7  200E9                     CALL 0E9[I2C_delay_1us]
 0E8  25000                     RETURN 
 0E9                            ;
 0E9                            ; The base delay is 1us and takes ((4 x I2C_time_reference) + 6) clock cycles
 0E9                            ; to execute including the CALL instruction required to invoke it.
 0E9                            ;
 0E9                            ; For example, if the clock frequency is 100MHz then 'I2C_time_reference' should be set
 0E9                            ; to 24'd. This will result in 24 iterations of the 'SUB' and 'JUMP NZ' loop resulting
 0E9                            ; in the execution of 48 instructions. The invoking 'CALL', the 'LOAD' and the 'RETURN'
 0E9                            ; bringing the total number of instructions to 51. All instructions take 2 clock cycles
 0E9                            ; to execute so that is a total of 102 clock cycles which take 1.02us at 100MHz.
 0E9                            ;  i.e. ((4 x I2C_time_reference) + 6) = ((4 x 24) + 6) = 102 clock cycles
 0E9                            ;
 0E9  01018      I2C_delay_1us: LOAD s0, 18[I2C_time_reference]
 0EA  19001     I2C_delay_loop: SUB s0, 01[1'd]
 0EB  360EA                     JUMP NZ, 0EA[I2C_delay_loop]
 0EC  25000                     RETURN 
 0ED                            ;
 0ED                            ;
 0ED                            ;------------------------------------------------------------------------------------------
 0ED                            ; End of 'i2c_routines.psm'
 0ED                            ;------------------------------------------------------------------------------------------
 0ED                            ;


All unused memory locations contain zero (equivalent to 'LOAD s0, s0')



List of PSM files that have been assembled

E:\HDMI_FIFO_Testv03\hdl\i2c\picoblaze\ad9984a_init.psm
E:\HDMI_FIFO_Testv03\hdl\i2c\picoblaze\soft_delays_100mhz.psm
E:\HDMI_FIFO_Testv03\hdl\i2c\picoblaze\i2c_routines.psm



List of defined constants

 CONSTANT name      Value        Source PSM File

 timestamp_hours    18'd         
 timestamp_minutes  50'd         
 timestamp_seconds  23'd         
 datestamp_year     14'd         
 datestamp_month    8'd          
 datestamp_day      05'd         
 NUL                00           
 BEL                07           
 BS                 08           
 HT                 09           
 LF                 0A           
 VT                 0B           
 CR                 0D           
 ESC                1B           
 DEL                7F           
 DCS                90           
 ST                 9C           
 I2C_time_reference 24'd         i2c_routines.psm
 I2C_input_port     02           i2c_routines.psm
 I2C_output_port    08           i2c_routines.psm
 I2C_clk            00000001'b   i2c_routines.psm
 I2C_data           00000010'b   i2c_routines.psm



No TABLEs defined



List of text strings

 STRING name       String         Source PSM File

 KCPSM6_version$   "v2.63"        
 datestamp$        "05 Aug 2014"  
 timestamp$        "18:50:23"     



List of line labels

   Label               Addr  Source PSM File

 * start               000   ad9984a_init.psm
   forever             005   ad9984a_init.psm
   AD9984A_init        006   ad9984a_init.psm
   i2c_write_AD9984A   06A   ad9984a_init.psm
 * pcf8574a_led_test   077   ad9984a_init.psm
 * delay_1ms           08C   soft_delays_100mhz.psm
   delay_20ms          090   soft_delays_100mhz.psm
 * delay_1s            094   soft_delays_100mhz.psm
   software_delay      098   soft_delays_100mhz.psm
   I2C_initialise      09E   i2c_routines.psm
   I2C_start           0A2   i2c_routines.psm
   I2C_stop            0A9   i2c_routines.psm
   I2C_Tx_byte         0AF   i2c_routines.psm
   I2C_Tx_next_bit     0B0   i2c_routines.psm
   I2C_Tx1             0B4   i2c_routines.psm
   I2C_Tx_tsu          0B5   i2c_routines.psm
 * I2C_Rx_byte         0B9   i2c_routines.psm
   I2C_Rx_next_bit     0BA   i2c_routines.psm
 * I2C_Tx_ACK          0BE   i2c_routines.psm
   I2C_clk_pulse       0BF   i2c_routines.psm
 * I2C_Tx_NACK         0C4   i2c_routines.psm
   I2C_Rx_ACK          0C6   i2c_routines.psm
   I2C_clk_Low         0C9   i2c_routines.psm
   I2C_clk_Z           0CD   i2c_routines.psm
   I2C_wait_clk_High   0CF   i2c_routines.psm
   I2C_data_Low        0D3   i2c_routines.psm
   I2C_data_Z          0D6   i2c_routines.psm
   I2C_Rx_bit          0D9   i2c_routines.psm
   I2C_delay_5us       0E3   i2c_routines.psm
   I2C_delay_4us       0E4   i2c_routines.psm
   I2C_delay_2us       0E6   i2c_routines.psm
   I2C_delay_1us       0E9   i2c_routines.psm
   I2C_delay_loop      0EA   i2c_routines.psm

      * Line label has not been referenced in any instructions.
        Hint - This may indicate unused code that could be
               removed to reduce the size of this program.



Instruction usage statistics

 Instruction    Instances

 LOAD             96
 STAR              -

 AND               2
 OR                3
 XOR               -

 ADD               -
 ADDCY             -
 SUB               3
 SUBCY             2

 TEST              4
 TESTCY            -
 COMPARE           -
 COMPARECY         -

 SL0               1
 SL1               -
 SLX               -
 SLA               1
 RL                -
 SR0               1
 SR1               -
 SRX               -
 SRA               -
 RR                -

 REGBANK           -

 INPUT             2
 OUTPUT            5
 OUTPUTK           -

 STORE             -
 FETCH             -

 DISABLE           -
 ENABLE            -
 RETURNI           -

 JUMP             12
 JUMP@             -
 CALL             87
 CALL@             -
 RETURN           18
 LOAD&RETURN       -

 HWBUILD           -



End of KCPSM6 log file.
