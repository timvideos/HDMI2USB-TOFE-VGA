KCPSM6 Assembler log file for program 'E:\I2C_Picoblaze\i2c_picoblaze\ad9984a_init.psm'.
Generated by KCPSM6 version v2.63
Ken Chapman - Xilinx Ltd - 20th December 2013

Assembly datestamp: 31 Jul 2014
Assembly timestamp: 07:03:28

Contents
  Assembly listing
  List of PSM files
  List of CONSTANTs
  List of TABLEs
  List of STRINGs
  List of line labels
  Instruction usage statistics


Last occupied address: 0EB hex
Nominal program memory size: 1K (1024)   address(9:0)
Actual memory size: 4096
  (Default memory size)
Occupied memory locations: 236
Memory locations available: 3860


Assembly listing

 Addr Code                      Instruction

 000                            ;CONSTANT AD9984A_ADDRESS, 4C  ;May need to uncomment this
 000                            NAMEREG s6, i2c_reg_adr
 000                            NAMEREG s7, i2c_reg_data
 000                            NAMEREG s8, AD9984A_ADDRESS       ; May need to comment this line
 000                            ;start: JUMP start
 000                            ; Slight delay for startup
 000  2008F                     CALL 08F[delay_20ms]
 001  2008F                     CALL 08F[delay_20ms]
 002  2009D                     CALL 09D[I2C_initialise]
 003  0184C                     LOAD s8[AD9984A_ADDRESS], 4C      ; May need to comment this line
 004  2001A                     CALL 01A[AD9984A_init]
 005  01838            forever: LOAD s8[AD9984A_ADDRESS], 38
 006  01600                     LOAD s6[i2c_reg_adr], 00
 007  017AA                     LOAD s7[i2c_reg_data], AA
 008  2007E                     CALL 07E[i2c_write_AD9984A]
 009  01839                     LOAD s8[AD9984A_ADDRESS], 39
 00A  01600                     LOAD s6[i2c_reg_adr], 00
 00B  01755                     LOAD s7[i2c_reg_data], 55
 00C  2007E                     CALL 07E[i2c_write_AD9984A]
 00D  2008F                     CALL 08F[delay_20ms]
 00E  2008F                     CALL 08F[delay_20ms]
 00F                            ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 00F                            ; Now alternate LEDs
 00F                            ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 00F  01838                     LOAD s8[AD9984A_ADDRESS], 38
 010  01600                     LOAD s6[i2c_reg_adr], 00
 011  01755                     LOAD s7[i2c_reg_data], 55
 012  2007E                     CALL 07E[i2c_write_AD9984A]
 013  01839                     LOAD s8[AD9984A_ADDRESS], 39
 014  01600                     LOAD s6[i2c_reg_adr], 00
 015  017AA                     LOAD s7[i2c_reg_data], AA
 016  2007E                     CALL 07E[i2c_write_AD9984A]
 017  2008F                     CALL 08F[delay_20ms]
 018  2008F                     CALL 08F[delay_20ms]
 019  22005                     JUMP 005[forever]
 01A              AD9984A_init: 
 01A                            ;--------------------------------
 01A                            ; Input and Output Configuration
 01A                            ;--------------------------------
 01A                            ; 0x1E: Input select=0, PWRDWN Polarity to 1 (+) instead of (-) hence B4 instead of B0
 01A  0161E                     LOAD s6[i2c_reg_adr], 1E
 01B  017B4                     LOAD s7[i2c_reg_data], B4
 01C  2007E                     CALL 07E[i2c_write_AD9984A]
 01D                            ; 0x1F: Output Sel 1
 01D  0161F                     LOAD s6[i2c_reg_adr], 1F
 01E  01794                     LOAD s7[i2c_reg_data], 94
 01F  2007E                     CALL 07E[i2c_write_AD9984A]
 020                            ; 0x20: Output Sel 2 #Enabled Filter with 0x07 [alt: 0x05]
 020  01620                     LOAD s6[i2c_reg_adr], 20
 021  01707                     LOAD s7[i2c_reg_data], 07
 022  2007E                     CALL 07E[i2c_write_AD9984A]
 023                            ;-----------------
 023                            ; Analog settings
 023                            ;-----------------
 023                            ; 0x05: red gain[8:2]
 023  01605                     LOAD s6[i2c_reg_adr], 05
 024  01740                     LOAD s7[i2c_reg_data], 40
 025  2007E                     CALL 07E[i2c_write_AD9984A]
 026                            ; 0x06: red gain[1:0]
 026  01606                     LOAD s6[i2c_reg_adr], 06
 027  01700                     LOAD s7[i2c_reg_data], 00
 028  2007E                     CALL 07E[i2c_write_AD9984A]
 029                            ; 0x07: grn gain[8:2]
 029  01607                     LOAD s6[i2c_reg_adr], 07
 02A  01740                     LOAD s7[i2c_reg_data], 40
 02B  2007E                     CALL 07E[i2c_write_AD9984A]
 02C                            ; 0x08: grn gain[1:0]
 02C  01608                     LOAD s6[i2c_reg_adr], 08
 02D  01700                     LOAD s7[i2c_reg_data], 00
 02E  2007E                     CALL 07E[i2c_write_AD9984A]
 02F                            ; 0x09: blu gain[8:2]
 02F  01609                     LOAD s6[i2c_reg_adr], 09
 030  01740                     LOAD s7[i2c_reg_data], 40
 031  2007E                     CALL 07E[i2c_write_AD9984A]
 032                            ; 0x0A: blu gain[1:0]
 032  0160A                     LOAD s6[i2c_reg_adr], 0A
 033  01700                     LOAD s7[i2c_reg_data], 00
 034  2007E                     CALL 07E[i2c_write_AD9984A]
 035                            ; 0x0B: red offset[10:3] #[Alt: 0x00]
 035  0160B                     LOAD s6[i2c_reg_adr], 0B
 036  017FF                     LOAD s7[i2c_reg_data], FF
 037  2007E                     CALL 07E[i2c_write_AD9984A]
 038                            ; 0x0C: red offset[2:0] #[Alt: 0x80]
 038  0160C                     LOAD s6[i2c_reg_adr], 0C
 039  017FF                     LOAD s7[i2c_reg_data], FF
 03A  2007E                     CALL 07E[i2c_write_AD9984A]
 03B                            ; 0x0D: grn offset[10:3] #[Alt: 0x00]
 03B  0160D                     LOAD s6[i2c_reg_adr], 0D
 03C  017FF                     LOAD s7[i2c_reg_data], FF
 03D  2007E                     CALL 07E[i2c_write_AD9984A]
 03E                            ; 0x0E: grn offset[2:0] #[Alt: 0x80]
 03E  0160E                     LOAD s6[i2c_reg_adr], 0E
 03F  017FF                     LOAD s7[i2c_reg_data], FF
 040  2007E                     CALL 07E[i2c_write_AD9984A]
 041                            ; 0x0F: blu offset[10:3] #[Alt: 0x00]
 041  0160F                     LOAD s6[i2c_reg_adr], 0F
 042  017FF                     LOAD s7[i2c_reg_data], FF
 043  2007E                     CALL 07E[i2c_write_AD9984A]
 044                            ; 0x10: blu offset[2:0] #[Alt: 0x80]
 044  01610                     LOAD s6[i2c_reg_adr], 10
 045  017FF                     LOAD s7[i2c_reg_data], FF
 046  2007E                     CALL 07E[i2c_write_AD9984A]
 047                            ; 0x1B: Clamp and offset, Turn on auto offset with 0x3B #Disable auto-offset with 0x1B [alt:0x2B]
 047  0161B                     LOAD s6[i2c_reg_adr], 1B
 048  0171B                     LOAD s7[i2c_reg_data], 1B
 049  2007E                     CALL 07E[i2c_write_AD9984A]
 04A                            ; 0x3C: Auto Gain, Enable auto gain matching
 04A  0163C                     LOAD s6[i2c_reg_adr], 3C
 04B  0170E                     LOAD s7[i2c_reg_data], 0E
 04C  2007E                     CALL 07E[i2c_write_AD9984A]
 04D                            ;-------------------------------
 04D                            ; Required Test Register Writes
 04D                            ;-------------------------------
 04D                            ; 0x2D:
 04D  0162D                     LOAD s6[i2c_reg_adr], 2D
 04E  017E8                     LOAD s7[i2c_reg_data], E8
 04F  2007E                     CALL 07E[i2c_write_AD9984A]
 050                            ; 0x2E:
 050  0162E                     LOAD s6[i2c_reg_adr], 2E
 051  017E0                     LOAD s7[i2c_reg_data], E0
 052  2007E                     CALL 07E[i2c_write_AD9984A]
 053                            ; 0x28:
 053  01628                     LOAD s6[i2c_reg_adr], 28
 054  017BF                     LOAD s7[i2c_reg_data], BF
 055  2007E                     CALL 07E[i2c_write_AD9984A]
 056                            ; 0x29:
 056  01629                     LOAD s6[i2c_reg_adr], 29
 057  01702                     LOAD s7[i2c_reg_data], 02
 058  2007E                     CALL 07E[i2c_write_AD9984A]
 059                            ;-----------------
 059                            ; Timing Settings
 059                            ;-----------------
 059                            ; 0x01: PLLDIV[11:4]
 059  01601                     LOAD s6[i2c_reg_adr], 01
 05A  01754                     LOAD s7[i2c_reg_data], 54
 05B  2007E                     CALL 07E[i2c_write_AD9984A]
 05C                            ; 0x02: PLLDIV[3:0]
 05C  01602                     LOAD s6[i2c_reg_adr], 02
 05D  01700                     LOAD s7[i2c_reg_data], 00
 05E  2007E                     CALL 07E[i2c_write_AD9984A]
 05F                            ; 0x03: VCO Ctrl
 05F  01603                     LOAD s6[i2c_reg_adr], 03
 060  017A0                     LOAD s7[i2c_reg_data], A0
 061  2007E                     CALL 07E[i2c_write_AD9984A]
 062                            ; 0x04: Phase adjust
 062  01604                     LOAD s6[i2c_reg_adr], 04
 063  01780                     LOAD s7[i2c_reg_data], 80
 064  2007E                     CALL 07E[i2c_write_AD9984A]
 065                            ; 0x13: HS width = 136 pixel clks = 0x88
 065  01613                     LOAD s6[i2c_reg_adr], 13
 066  01788                     LOAD s7[i2c_reg_data], 88
 067  2007E                     CALL 07E[i2c_write_AD9984A]
 068                            ; 0x19: Clamp Placement [alt: 0x04]
 068  01619                     LOAD s6[i2c_reg_adr], 19
 069  01701                     LOAD s7[i2c_reg_data], 01
 06A  2007E                     CALL 07E[i2c_write_AD9984A]
 06B                            ; 0x1A: Clamp duration [alt: 0x82]
 06B  0161A                     LOAD s6[i2c_reg_adr], 1A
 06C  0178C                     LOAD s7[i2c_reg_data], 8C
 06D  2007E                     CALL 07E[i2c_write_AD9984A]
 06E                            ;-----------------
 06E                            ; VSYNC Control
 06E                            ;-----------------
 06E                            ; 0x14: Enable VSYNC Filter
 06E  01614                     LOAD s6[i2c_reg_adr], 14
 06F  0171C                     LOAD s7[i2c_reg_data], 1C
 070  2007E                     CALL 07E[i2c_write_AD9984A]
 071                            ; 0x15: Set VSYNC duration to 6 HSYNCs
 071  01615                     LOAD s6[i2c_reg_adr], 15
 072  01706                     LOAD s7[i2c_reg_data], 06
 073  2007E                     CALL 07E[i2c_write_AD9984A]
 074                            ; 0x16: Precoast
 074  01616                     LOAD s6[i2c_reg_adr], 16
 075  01703                     LOAD s7[i2c_reg_data], 03
 076  2007E                     CALL 07E[i2c_write_AD9984A]
 077                            ; 0x17: Postcoast
 077  01617                     LOAD s6[i2c_reg_adr], 17
 078  01706                     LOAD s7[i2c_reg_data], 06
 079  2007E                     CALL 07E[i2c_write_AD9984A]
 07A                            ;-----------------
 07A                            ; SOG Control
 07A                            ;-----------------
 07A                            ; 0x1D: Enable Raw HSYNCs on SOGOUT
 07A  0161D                     LOAD s6[i2c_reg_adr], 1D
 07B  0177D                     LOAD s7[i2c_reg_data], 7D
 07C  2007E                     CALL 07E[i2c_write_AD9984A]
 07D                            ;All Done! Now return to calling part
 07D  25000                     RETURN 
 07E         i2c_write_AD9984A: 
 07E                            ; I2C START Signal
 07E  200A1                     CALL 0A1[I2C_start]
 07F                            ; I2C Write device address with write-bit(LSB=0) set
 07F  00580                     LOAD s5, s8[AD9984A_ADDRESS]      ;7-bit I2C device address of AD9984A
 080  14506                     SL0 s5                            ;Write operation signified by LSB = 0
 081  200AE                     CALL 0AE[I2C_Tx_byte]
 082  200C5                     CALL 0C5[I2C_Rx_ACK]
 083                            ; Write AD9984A Register Address
 083  00560                     LOAD s5, s6[i2c_reg_adr]
 084  200AE                     CALL 0AE[I2C_Tx_byte]
 085  200C5                     CALL 0C5[I2C_Rx_ACK]
 086                            ; Write AD9984A Register Data
 086  00570                     LOAD s5, s7[i2c_reg_data]
 087  200AE                     CALL 0AE[I2C_Tx_byte]
 088  200C5                     CALL 0C5[I2C_Rx_ACK]
 089                            ; I2C STOP Signal
 089  200A8                     CALL 0A8[I2C_stop]
 08A  25000                     RETURN 
 08B                            INCLUDE "E:\I2C_Picoblaze\i2c_picoblaze\soft_delays_100mhz.psm"["soft_delays_100mhz.psm"]
 08B                            ;
 08B                            ;------------------------------------------------------------------------------------------
 08B                            ; Copyright © 2012-2013, Xilinx, Inc.
 08B                            ; This file contains confidential and proprietary information of Xilinx, Inc. and is
 08B                            ; protected under U.S. and international copyright and other intellectual property laws.
 08B                            ;------------------------------------------------------------------------------------------
 08B                            ;
 08B                            ; Disclaimer:
 08B                            ; This disclaimer is not a license and does not grant any rights to the materials
 08B                            ; distributed herewith. Except as otherwise provided in a valid license issued to
 08B                            ; you by Xilinx, and to the maximum extent permitted by applicable law: (1) THESE
 08B                            ; MATERIALS ARE MADE AVAILABLE "AS IS" AND WITH ALL FAULTS, AND XILINX HEREBY
 08B                            ; DISCLAIMS ALL WARRANTIES AND CONDITIONS, EXPRESS, IMPLIED, OR STATUTORY,
 08B                            ; INCLUDING BUT NOT LIMITED TO WARRANTIES OF MERCHANTABILITY, NON-INFRINGEMENT,
 08B                            ; OR FITNESS FOR ANY PARTICULAR PURPOSE; and (2) Xilinx shall not be liable
 08B                            ; (whether in contract or tort, including negligence, or under any other theory
 08B                            ; of liability) for any loss or damage of any kind or nature related to, arising
 08B                            ; under or in connection with these materials, including for any direct, or any
 08B                            ; indirect, special, incidental, or consequential loss or damage (including loss
 08B                            ; of data, profits, goodwill, or any type of loss or damage suffered as a result
 08B                            ; of any action brought by a third party) even if such damage or loss was
 08B                            ; reasonably foreseeable or Xilinx had been advised of the possibility of the same.
 08B                            ;
 08B                            ; CRITICAL APPLICATIONS
 08B                            ; Xilinx products are not designed or intended to be fail-safe, or for use in any
 08B                            ; application requiring fail-safe performance, such as life-support or safety
 08B                            ; devices or systems, Class III medical devices, nuclear facilities, applications
 08B                            ; related to the deployment of airbags, or any other applications that could lead
 08B                            ; to death, personal injury, or severe property or environmental damage
 08B                            ; (individually and collectively, "Critical Applications"). Customer assumes the
 08B                            ; sole risk and liability of any use of Xilinx products in Critical Applications,
 08B                            ; subject only to applicable laws and regulations governing limitations on product
 08B                            ; liability.
 08B                            ;
 08B                            ; THIS COPYRIGHT NOTICE AND DISCLAIMER MUST BE RETAINED AS PART OF THIS FILE AT ALL TIMES.
 08B                            ;
 08B                            ;------------------------------------------------------------------------------------------
 08B                            ;
 08B                            ;             _  ______ ____  ____  __  __  __
 08B                            ;            | |/ / ___|  _ \/ ___||  \/  |/ /_
 08B                            ;            | ' / |   | |_) \___ \| |\/| | '_ \
 08B                            ;            | . \ |___|  __/ ___) | |  | | (_) )
 08B                            ;            |_|\_\____|_|   |____/|_|  |_|\___/
 08B                            ;
 08B                            ;
 08B                            ;                PicoBlaze Reference Design.
 08B                            ;
 08B                            ;
 08B                            ; Ken Chapman - Xilinx Ltd
 08B                            ;
 08B                            ; 6th September 2012 - Initial version
 08B                            ;    18th March 2013 - Addition of 20ms delay
 08B                            ;
 08B                            ; This file contains routines that implement delays in software. It should be recognised
 08B                            ; that the delay periods are the result of executing instructions, and because every
 08B                            ; instruction takes 2 clock cycles to execute, it is possible to determine the exact
 08B                            ; delay period. However, besides the obvious dependency on the clock frequency, it
 08B                            ; should also be recognised that any interrupts to KCPSM6 (or use of sleep mode) will
 08B                            ; impact the timing. In general, it is better only to use soft delay routines in
 08B                            ; situations where approximate timing is adequate; in those situations KCPSM6 will often
 08B                            ; exceed your requirements.
 08B                            ;
 08B                            ;
 08B                            ;------------------------------------------------------------------------------------------
 08B                            ; Software Delays based on 100MHz clock
 08B                            ;------------------------------------------------------------------------------------------
 08B                            ;
 08B                            ; The number of iterations of a delay loop required to form each delay required are
 08B                            ; loaded into the register set [s2,s1,s0] and then the delay loop is started.
 08B                            ;
 08B                            ; Registers used s0, s1, s2
 08B                            ;
 08B                            ; 1ms is 10,000 x 100ns     (10,000 = 002710 hex)
 08B                            ;
 08B  01200          delay_1ms: LOAD s2, 00
 08C  01127                     LOAD s1, 27
 08D  01010                     LOAD s0, 10
 08E  22097                     JUMP 097[software_delay]
 08F                            ;
 08F                            ; 20ms is 200,000 x 100ns     (200,000 = 030D40 hex)
 08F                            ;
 08F  01203         delay_20ms: LOAD s2, 03
 090  0110D                     LOAD s1, 0D
 091  01040                     LOAD s0, 40
 092  22097                     JUMP 097[software_delay]
 093                            ;
 093                            ;
 093                            ; 1s is 10,000,000 x 100ns     (10,000,000 = 989680 hex)
 093                            ;
 093  01298           delay_1s: LOAD s2, 98
 094  01196                     LOAD s1, 96
 095  01080                     LOAD s0, 80
 096  22097                     JUMP 097[software_delay]
 097                            ;
 097                            ; The delay loop decrements [s2,s1,s0] until it reaches zero
 097                            ; Each decrement cycle is 5 instructions which is 10 clock cycles (100ns at 100MHz)
 097                            ;
 097  00000     software_delay: LOAD s0, s0                       ;pad loop to make it 10 clock cycles (5 instructions)
 098  19001                     SUB s0, 01[1'd]
 099  1B100                     SUBCY s1, 00[0'd]
 09A  1B200                     SUBCY s2, 00[0'd]
 09B  36097                     JUMP NZ, 097[software_delay]
 09C  25000                     RETURN 
 09D                            ;
 09D                            ;
 09D                            ;------------------------------------------------------------------------------------------
 09D                            ; End of 'soft_delays_100mhz.psm'
 09D                            ;------------------------------------------------------------------------------------------
 09D                            ;
 09D                            INCLUDE "E:\I2C_Picoblaze\i2c_picoblaze\i2c_routines.psm"["i2c_routines.psm"]
 09D                            ;
 09D                            ;------------------------------------------------------------------------------------------
 09D                            ; Copyright © 2011-2012, Xilinx, Inc.
 09D                            ; This file contains confidential and proprietary information of Xilinx, Inc. and is
 09D                            ; protected under U.S. and international copyright and other intellectual property laws.
 09D                            ;------------------------------------------------------------------------------------------
 09D                            ;
 09D                            ; Disclaimer:
 09D                            ; This disclaimer is not a license and does not grant any rights to the materials
 09D                            ; distributed herewith. Except as otherwise provided in a valid license issued to
 09D                            ; you by Xilinx, and to the maximum extent permitted by applicable law: (1) THESE
 09D                            ; MATERIALS ARE MADE AVAILABLE "AS IS" AND WITH ALL FAULTS, AND XILINX HEREBY
 09D                            ; DISCLAIMS ALL WARRANTIES AND CONDITIONS, EXPRESS, IMPLIED, OR STATUTORY,
 09D                            ; INCLUDING BUT NOT LIMITED TO WARRANTIES OF MERCHANTABILITY, NON-INFRINGEMENT,
 09D                            ; OR FITNESS FOR ANY PARTICULAR PURPOSE; and (2) Xilinx shall not be liable
 09D                            ; (whether in contract or tort, including negligence, or under any other theory
 09D                            ; of liability) for any loss or damage of any kind or nature related to, arising
 09D                            ; under or in connection with these materials, including for any direct, or any
 09D                            ; indirect, special, incidental, or consequential loss or damage (including loss
 09D                            ; of data, profits, goodwill, or any type of loss or damage suffered as a result
 09D                            ; of any action brought by a third party) even if such damage or loss was
 09D                            ; reasonably foreseeable or Xilinx had been advised of the possibility of the same.
 09D                            ;
 09D                            ; CRITICAL APPLICATIONS
 09D                            ; Xilinx products are not designed or intended to be fail-safe, or for use in any
 09D                            ; application requiring fail-safe performance, such as life-support or safety
 09D                            ; devices or systems, Class III medical devices, nuclear facilities, applications
 09D                            ; related to the deployment of airbags, or any other applications that could lead
 09D                            ; to death, personal injury, or severe property or environmental damage
 09D                            ; (individually and collectively, "Critical Applications"). Customer assumes the
 09D                            ; sole risk and liability of any use of Xilinx products in Critical Applications,
 09D                            ; subject only to applicable laws and regulations governing limitations on product
 09D                            ; liability.
 09D                            ;
 09D                            ; THIS COPYRIGHT NOTICE AND DISCLAIMER MUST BE RETAINED AS PART OF THIS FILE AT ALL TIMES.
 09D                            ;
 09D                            ;------------------------------------------------------------------------------------------
 09D                            ;
 09D                            ;
 09D                            ;             _  ______ ____  ____  __  __  __
 09D                            ;            | |/ / ___|  _ \/ ___||  \/  |/ /_
 09D                            ;            | ' / |   | |_) \___ \| |\/| | '_ \
 09D                            ;            | . \ |___|  __/ ___) | |  | | (_) )
 09D                            ;            |_|\_\____|_|   |____/|_|  |_|\___/
 09D                            ;
 09D                            ;
 09D                            ;                PicoBlaze Reference Design.
 09D                            ;
 09D                            ;
 09D                            ; Routines for General Purpose I2C Communication
 09D                            ;
 09D                            ; Ken Chapman - Xilinx Ltd
 09D                            ;
 09D                            ; 9th March 2012 - Initial Version
 09D                            ; 12th October 2012 - Adjustments to values assigned to constant directives
 09D                            ; 16th October 2012 - Code optimisation (lowest level signal drive routines)
 09D                            ; 25th October 2012 - Correct definition of a binary value (functionally identical)
 09D                            ; 6th November 2012 - Correction to comment only
 09D                            ;
 09D                            ;
 09D                            ;     NOTE - This is not a standalone PSM file. Include this file in a program that
 09D                            ;            then calls these routines and works with the values in scratch pad memory.
 09D                            ;
 09D                            ;                INCLUDE "i2c_routines.psm"
 09D                            ;
 09D                            ;
 09D                            ;     IMPORTANT - These routines interact with input and output ports which must
 09D                            ;                 be appropriately defined to drive and read the physical I2C
 09D                            ;                 signals. Four CONSTANT directives must define values consistent
 09D                            ;                 with your port definitions and a further CONSTANT must be defined
 09D                            ;                 that is related to the frequency of the clock being applied to
 09D                            ;                 KCPSM6 in your design (Please see descriptions below).
 09D                            ;
 09D                            ;
 09D                            ; INTRODUCTION
 09D                            ; ------------
 09D                            ;
 09D                            ; The following routines implement an I2C 'Master' with a communication data rate
 09D                            ; approaching (but not exceeding) 100KHz. The I2C bus connects to the FPGA I/O
 09D                            ; pins which must in turn be connected to KCPSM6 input and output ports. Therefore
 09D                            ; your hardware design must be appropriate before these routines can be used and
 09D                            ; these routines need to know which ports you have allocated for I2C in your design.
 09D                            ;
 09D                            ; With the hardware in place, the routines provide the ability to perform each of the
 09D                            ; actions generally required for an I2C transaction including bus idle, Start (S),
 09D                            ; Repeated Start (Sr), Stop (P), Transmission of Acknowledge (ACK) or No Acknowledge
 09D                            ; (NACK), receiving and testing of Acknowledge (ACK) from a slave and of course the
 09D                            ; ability to transmit and receive bytes used for addressing, commands and data.
 09D                            ;
 09D                            ; It is assumed that you are familiar with I2C, so the descriptions contained in this
 09D                            ; file are concerned primarily with how KCPSM6 is used to implement the signaling and
 09D                            ; elements of the transactions rather than to teach I2C itself. In the end, it is the
 09D                            ; sequence in which these routines are invoked that will result in successful
 09D                            ; communication with a slave device and that requires an understanding of the needs
 09D                            ; of each particular slave to implement correctly (i.e. a study of data sheets for
 09D                            ; slave devices when writing higher level code).
 09D                            ;
 09D                            ; NOTE - As provided, these routines assume that KCPSM6 is the only I2C master connected
 09D                            ;        to the bus. A multiple master implementation would be possible but these routines
 09D                            ;        are not suitable in such arrangements.
 09D                            ;
 09D                            ;
 09D                            ;
 09D                            ; Code typical of an I2C write of data to a slave using the routines provided...
 09D                            ;
 09D                            ;    CALL I2C_initialise
 09D                            ;    CALL I2C_start
 09D                            ;    LOAD s5, slave_address       ;7-bit slave address
 09D                            ;    SL0 s5                       ;Write operation signified by LSB = 0
 09D                            ;    CALL I2C_Tx_byte
 09D                            ;    CALL I2C_Rx_ACK
 09D                            ;    JUMP C, communication_fail   ;did the slave respond?
 09D                            ;    LOAD s5, data_byte1
 09D                            ;    CALL I2C_Tx_byte
 09D                            ;    CALL I2C_Rx_ACK
 09D                            ;    LOAD s5, data_byte2
 09D                            ;    CALL I2C_Tx_byte
 09D                            ;    CALL I2C_Rx_ACK
 09D                            ;    CALL I2C_stop
 09D                            ;
 09D                            ;
 09D                            ; Code typical of an I2C read of data from a slave using the routines provided...
 09D                            ;
 09D                            ;    CALL I2C_initialise
 09D                            ;    CALL I2C_start
 09D                            ;    LOAD s5, slave_address       ;7-bit slave address
 09D                            ;    SL0 s5                       ;Write operation signified by LSB = 0
 09D                            ;    CALL I2C_Tx_byte
 09D                            ;    CALL I2C_Rx_ACK
 09D                            ;    JUMP C, communication_fail   ;did the slave respond?
 09D                            ;    LOAD s5, slave_command
 09D                            ;    CALL I2C_Tx_byte
 09D                            ;    CALL I2C_Rx_ACK
 09D                            ;    CALL I2C_start               ;bus restart (Sr)
 09D                            ;    LOAD s5, slave_address       ;7-bit slave address
 09D                            ;    SL1 s5                       ;Read operation signified by LSB = 1
 09D                            ;    CALL I2C_Tx_byte
 09D                            ;    CALL I2C_Rx_ACK
 09D                            ;    CALL I2C_Rx_byte
 09D                            ;    STORE s5, data1
 09D                            ;    CALL I2C_Tx_ACK
 09D                            ;    CALL I2C_Rx_byte
 09D                            ;    STORE s5, data2
 09D                            ;    CALL I2C_Tx_NACK             ;transmit NACK before Stop
 09D                            ;    CALL I2C_stop
 09D                            ;
 09D                            ;
 09D                            ;------------------------------------------------------------------------------------------
 09D                            ; Hardware
 09D                            ;------------------------------------------------------------------------------------------
 09D                            ;
 09D                            ; Clock
 09D                            ; -----
 09D                            ;
 09D                            ; All KCPSM6 instructions take 2 clock cycles to execute and it is this predictability
 09D                            ; that these routines exploit to ensure that the I2C communication rate does not exceed
 09D                            ; 100KHz. However, these routines will only implement the correct timing if something
 09D                            ; related to the frequency of the clock provide to KCPSM6 is known and the CONSTANT
 09D                            ; directive below must be defined correctly to achieve that.
 09D                            ;
 09D                            CONSTANT I2C_time_reference, 24'd
 09D                            ;
 09D                            ;  I2C_time_reference =  ( fclk - 6 ) / 4
 09D                            ;
 09D                            ;   Where...
 09D                            ;     'fclk' is the clock frequency applied to KCPSM6 in MHz.
 09D                            ;     Any non-integer result should be rounded up.
 09D                            ;     Typical values....
 09D                            ;
 09D                            ;          fclk (MHz)      I2C_time_reference
 09D                            ;            50                  11'd
 09D                            ;            80                  19'd
 09D                            ;           100                  24'd
 09D                            ;           200                  49'd
 09D                            ;
 09D                            ;
 09D                            ;
 09D                            ; I2C Bus and KCPSM6 ports
 09D                            ; ------------------------
 09D                            ;
 09D                            ; An I2C bus consists of two signals called 'CLK' and 'DATA' or something similar. Both
 09D                            ; signals need to be connected to the FPGA via 'open collector' style bidirectional I/O
 09D                            ; pins with a pull-up resistor (typically an external resistor but the built in pull-up
 09D                            ; resistor of the IOB may also be enabled in some cases). These I/O pins must then be
 09D                            ; connected to a KCPSM6 input port and KCPSM6 output port such that both signals can
 09D                            ; be both driven and read.
 09D                            ;
 09D                            ;  The input port used to read the logic levels on the CLK and DATA signals external
 09D                            ;  to the FPGA.
 09D                            ;
 09D                            ;  The output port is used to control the output drive of the CLK and DATA pins.
 09D                            ;    Since the pins are 'open collector' style then when KCPSM6 outputs...
 09D                            ;      '0' will result in the signal being driven Low.
 09D                            ;      '1' will result in the pin becoming tri-state (Z) so the signal will be pulled
 09D                            ;          High by the resistor or can be driven or held low by a slave device.
 09D                            ;
 09D                            ; In a typical VHDL based design the following snippets of code could be inserted at the
 09D                            ; appropriate places to define the I2C pins and connection to KCPSM6...
 09D                            ;
 09D                            ;   entity <name>
 09D                            ;   Port (   i2c_clk : inout std_logic;
 09D                            ;           i2c_data : inout std_logic;
 09D                            ;
 09D                            ;
 09D                            ;   signal  drive_i2c_clk : std_logic;
 09D                            ;   signal drive_i2c_data : std_logic;
 09D                            ;
 09D                            ;
 09D                            ;   i2c_clk  <= '0' when drive_i2c_clk = '0' else 'Z';
 09D                            ;   i2c_data <= '0' when drive_i2c_data = '0' else 'Z';
 09D                            ;
 09D                            ;
 09D                            ;   input_ports: process(clk)
 09D                            ;   begin
 09D                            ;     if clk'event and clk = '1' then
 09D                            ;       case port_id(1 downto 0) is
 09D                            ;
 09D                            ;         -- Read I2C Bus at port address 02 hex
 09D                            ;         when "10" =>    in_port(0) <= i2c_clk;
 09D                            ;                         in_port(1) <= i2c_data;
 09D                            ;
 09D                            ;
 09D                            ;   output_ports: process(clk)
 09D                            ;   begin
 09D                            ;     if clk'event and clk = '1' then
 09D                            ;       if write_strobe = '1' then
 09D                            ;
 09D                            ;         -- Write to I2C Bus at port address 08 hex
 09D                            ;         if port_id(3) = '1' then
 09D                            ;           drive_i2c_clk <= out_port(0);
 09D                            ;           drive_i2c_data <= out_port(1);
 09D                            ;         end if;
 09D                            ;
 09D                            ;
 09D                            ;
 09D                            ; To correspond with the definition of the input and output ports, the four CONSTANT
 09D                            ; directives below must be set correctly before these I2C routines are used. The
 09D                            ; values shown below correspond with the VHDL snippets above.
 09D                            ;
 09D                            CONSTANT I2C_input_port, 02       ;port address of I2C input port
 09D                            CONSTANT I2C_output_port, 08      ;port address of I2C output port
 09D                            ;
 09D                            CONSTANT I2C_clk, 00000001'b      ;Bit to which CLK is assigned on both ports
 09D                            CONSTANT I2C_data, 00000010'b     ;Bit to which DATA is assigned on both ports
 09D                            ;
 09D                            ;
 09D                            ;------------------------------------------------------------------------------------------
 09D                            ; Registers
 09D                            ;------------------------------------------------------------------------------------------
 09D                            ;
 09D                            ; The following registers within the currently active bank are used by these routines....
 09D                            ;
 09D                            ;    s0, s1, s5 and sF
 09D                            ;
 09D                            ;
 09D                            ; IMPORTANT - Register 'sF' is used to control and remember the drive values of the CLK
 09D                            ;             and DATA signals so its contents MUST NOT be altered between calls to the
 09D                            ;             various routines used to construct a complete I2C transaction. The routine
 09D                            ;             called 'I2C_initialise' is typically used before starting any transaction
 09D                            ;             as it will initialise 'sF' as well as the actual I2C interface.
 09D                            ;
 09D                            ;
 09D                            ;------------------------------------------------------------------------------------------
 09D                            ; Routine to initialise the CLK and DATA signals (and 'sF')
 09D                            ;------------------------------------------------------------------------------------------
 09D                            ;
 09D                            ; Places CLK and DATA into tri-state (Z) so that both lines reach idle High level.
 09D                            ; This also initialises register sF ready for other routines forming a transaction.
 09D                            ;
 09D                            ; This routine MUST be used before starting the first I2C transaction and before any
 09D                            ; further transaction if the contents of register 'sF' have been compromised since the
 09D                            ; end of the last I2C transaction.
 09D                            ;
 09D  01F01     I2C_initialise: LOAD sF, 01[I2C_clk]              ;CLK = Z
 09E  05F02                     OR sF, 02[I2C_data]               ;DATA = Z
 09F  2DF08                     OUTPUT sF, 08[I2C_output_port]
 0A0  25000                     RETURN 
 0A1                            ;
 0A1                            ;
 0A1                            ;------------------------------------------------------------------------------------------
 0A1                            ; Routine issue an I2C Start (S) or Repeated Start (Sr) condition.
 0A1                            ;------------------------------------------------------------------------------------------
 0A1                            ;
 0A1                            ; Used to begin any I2C transaction or performed during a transaction when changing the
 0A1                            ; from an write to a read.
 0A1                            ;
 0A1                            ; The Start (S) or Repeated Start (Sr) condition is signified by a High to Low transition
 0A1                            ; of the DATA line whilst the CLK line is High.
 0A1                            ;
 0A1  200D5          I2C_start: CALL 0D5[I2C_data_Z]              ;DATA = Z (High)
 0A2  200CC                     CALL 0CC[I2C_clk_Z]               ;CLK = Z (waits until definitely High)
 0A3  200E2                     CALL 0E2[I2C_delay_5us]           ;delay before start (S)
 0A4  200D2                     CALL 0D2[I2C_data_Low]            ;High to How transition on DATA whilst CLK is High
 0A5  200E3                     CALL 0E3[I2C_delay_4us]
 0A6  200C8                     CALL 0C8[I2C_clk_Low]             ;CLK = 0 (plus 5us delay)
 0A7  25000                     RETURN 
 0A8                            ;
 0A8                            ;
 0A8                            ;------------------------------------------------------------------------------------------
 0A8                            ; Routine issue an I2C Stop (P) condition
 0A8                            ;------------------------------------------------------------------------------------------
 0A8                            ;
 0A8                            ; Used to end any I2C transaction.
 0A8                            ;
 0A8                            ; The Stop (S) condition is signified by a Low to High transition of the DATA line whilst
 0A8                            ; the CLK line is High.
 0A8                            ;
 0A8                            ; Note that following this routine the CARRY flag is '0' and can be used to confirm a
 0A8                            ; good I2C communication (see 'I2C_Rx_ACK' routine).
 0A8                            ;
 0A8  200D2           I2C_stop: CALL 0D2[I2C_data_Low]            ;DATA = 0
 0A9  200E2                     CALL 0E2[I2C_delay_5us]
 0AA  200CC                     CALL 0CC[I2C_clk_Z]               ;CLK = Z (waits until definitely High)
 0AB  200E3                     CALL 0E3[I2C_delay_4us]
 0AC  200D5                     CALL 0D5[I2C_data_Z]              ;DATA = Z (High)
 0AD  25000                     RETURN 
 0AE                            ;
 0AE                            ;
 0AE                            ;------------------------------------------------------------------------------------------
 0AE                            ; Routine to transmit one byte from the KCPSM6 master to a slave
 0AE                            ;------------------------------------------------------------------------------------------
 0AE                            ;
 0AE                            ; The byte to be transmitted must be provided in register 's5'.
 0AE                            ;
 0AE                            ; The byte is transmitted most significant bit (MSB) first. As each of the 8 bits are
 0AE                            ; presented to the DATA line the CLK line is pulsed High.
 0AE                            ;
 0AE  01180        I2C_Tx_byte: LOAD s1, 80[10000000'b]           ;8-bits to transmit starting with MSB
 0AF  0C510    I2C_Tx_next_bit: TEST s5, s1                       ;test data bit for High or Low
 0B0  360B3                     JUMP NZ, 0B3[I2C_Tx1]
 0B1  200D2                     CALL 0D2[I2C_data_Low]            ;DATA = 0
 0B2  220B4                     JUMP 0B4[I2C_Tx_tsu]
 0B3  200D5            I2C_Tx1: CALL 0D5[I2C_data_Z]              ;DATA = Z (High)
 0B4  200BE         I2C_Tx_tsu: CALL 0BE[I2C_clk_pulse]           ;generate clock pulse with delays
 0B5  1410E                     SR0 s1                            ;move to next bit
 0B6  39000                     RETURN C                          ;have 8 bits been transmitted?
 0B7  220AF                     JUMP 0AF[I2C_Tx_next_bit]
 0B8                            ;
 0B8                            ;
 0B8                            ;------------------------------------------------------------------------------------------
 0B8                            ; Routine to receive one byte from a slave
 0B8                            ;------------------------------------------------------------------------------------------
 0B8                            ;
 0B8                            ; The byte received will be returned in register 's5'.
 0B8                            ;
 0B8                            ; The byte is received most significant bit (MSB) first. Each  of the 8 bits are sampled
 0B8                            ; as the CLK line is pulsed High.
 0B8                            ;
 0B8  01108        I2C_Rx_byte: LOAD s1, 08[8'd]                  ;8-bits to receive
 0B9  200D8    I2C_Rx_next_bit: CALL 0D8[I2C_Rx_bit]              ;receive and shift bit into LSB of s5
 0BA  19101                     SUB s1, 01[1'd]                   ;count bits received
 0BB  360B9                     JUMP NZ, 0B9[I2C_Rx_next_bit]
 0BC  25000                     RETURN 
 0BD                            ;
 0BD                            ;
 0BD                            ;------------------------------------------------------------------------------------------
 0BD                            ; Routine to transmit Acknowledge (ACK) from KCPSM6 master to a slave
 0BD                            ;------------------------------------------------------------------------------------------
 0BD                            ;
 0BD                            ; An Acknowledge (ACK) bit is transmitted to a slave after receiving a byte of data.
 0BD                            ;
 0BD                            ; ACK is simply the transmission of a '0' requiring the DATA line to be driven Low whilst
 0BD                            ; the CLK line is pulsed High.
 0BD                            ;
 0BD  200D2         I2C_Tx_ACK: CALL 0D2[I2C_data_Low]            ;DATA = 0
 0BE                            ;
 0BE  200E2      I2C_clk_pulse: CALL 0E2[I2C_delay_5us]
 0BF  200CC                     CALL 0CC[I2C_clk_Z]               ;CLK = Z (waits until definitely High)
 0C0  200E3                     CALL 0E3[I2C_delay_4us]           ;clock pulse width
 0C1  200C8                     CALL 0C8[I2C_clk_Low]             ;end of CLK clock pulse includes 5us delay
 0C2  25000                     RETURN 
 0C3                            ;
 0C3                            ;
 0C3                            ;------------------------------------------------------------------------------------------
 0C3                            ; Routine to transmit No Acknowledge (NACK) from KCPSM6 master to a slave
 0C3                            ;------------------------------------------------------------------------------------------
 0C3                            ;
 0C3                            ; A No Acknowledge (NACK) bit is transmitted to a slave after receiving a byte of data and
 0C3                            ; typically used to signify to a slave that a read transaction has been completed.
 0C3                            ;
 0C3                            ; NACK is simply the transmission of a '1' requiring the DATA line to be driven High
 0C3                            ; whilst the CLK line is pulsed High.
 0C3                            ;
 0C3  200D5        I2C_Tx_NACK: CALL 0D5[I2C_data_Z]              ;DATA = Z (High)
 0C4  220BE                     JUMP 0BE[I2C_clk_pulse]           ;generate clock pulse (includes return)
 0C5                            ;
 0C5                            ;
 0C5                            ;------------------------------------------------------------------------------------------
 0C5                            ; Routine to receive and test the Acknowledge (ACK) from a slave
 0C5                            ;------------------------------------------------------------------------------------------
 0C5                            ;
 0C5                            ; The KCPSM6 master will receive an Acknowledge (ACK) bit from a slave following the
 0C5                            ; transmitted of a byte to the slave. Receiving an ACK indicates that the slave responded
 0C5                            ; as expected but receiving a No Acknowledge (NACK) implies that something went wrong!
 0C5                            ;
 0C5                            ; The KCPSM6 master will pulse the CLK line High and receive the acknowledge bit from the
 0C5                            ; slave. The received ACK bit will be returned in the least significant bit (LSB) of the
 0C5                            ; 's5' register. Furthermore, a test will be performed such that the CARRY flag will also
 0C5                            ; reveal if the bit was ACK or NACK.
 0C5                            ;
 0C5                            ;     Received ACK bit    Meaning      CARRY(C)
 0C5                            ;           0              ACK           0
 0C5                            ;           1              NACK          1
 0C5                            ;
 0C5                            ; Note that following the 'I2C_stop' routine the CARRY flag is '0'.
 0C5                            ;
 0C5  200D8         I2C_Rx_ACK: CALL 0D8[I2C_Rx_bit]              ;receive ACK bit into LSB of s5
 0C6  0D501                     TEST s5, 01[00000001'b]           ;set flags
 0C7  25000                     RETURN 
 0C8                            ;
 0C8                            ;
 0C8                            ;------------------------------------------------------------------------------------------
 0C8                            ; Subroutines used by the main I2C routines above
 0C8                            ;------------------------------------------------------------------------------------------
 0C8                            ;
 0C8                            ; These routines actually control the I2C signals an ensure that timing specifications
 0C8                            ; consistent with maximum bit rate of 100KHz are not exceeded.
 0C8                            ;
 0C8                            ;
 0C8                            ; Drive CLK Low and wait for 5us before doing anything else.
 0C8                            ;
 0C8  03FFE        I2C_clk_Low: AND sF, FE[~I2C_clk]              ;CLK = 0
 0C9  2DF08                     OUTPUT sF, 08[I2C_output_port]
 0CA  200E2                     CALL 0E2[I2C_delay_5us]
 0CB  25000                     RETURN 
 0CC                            ;
 0CC                            ;
 0CC                            ; Place CLK into tri-state (Z) so that it can go High.
 0CC                            ; Then wait for CLK to actually become High before returning because a slave
 0CC                            ; has the ability to stretch a clock to slow communication down.
 0CC                            ;
 0CC  05F01          I2C_clk_Z: OR sF, 01[I2C_clk]                ;CLK = Z
 0CD  2DF08                     OUTPUT sF, 08[I2C_output_port]
 0CE  09002  I2C_wait_clk_High: INPUT s0, 02[I2C_input_port]      ;read external signals
 0CF  0D001                     TEST s0, 01[I2C_clk]              ;test CLK bit
 0D0  320CE                     JUMP Z, 0CE[I2C_wait_clk_High]    ;wait if CLK held Low by slave
 0D1  25000                     RETURN 
 0D2                            ;
 0D2                            ;
 0D2                            ; Drive DATA Low and wait for 5us before doing anything else.
 0D2                            ;
 0D2  03FFD       I2C_data_Low: AND sF, FD[~I2C_data]             ;DATA = 0
 0D3  2DF08                     OUTPUT sF, 08[I2C_output_port]
 0D4  25000                     RETURN 
 0D5                            ;
 0D5                            ;
 0D5                            ; Place DATA into tri-state (Z) so that it can go High.
 0D5                            ; This can be used to transmit or receive a '1' but can also be used by the
 0D5                            ; slave to return a '0' by holding the data line Low against the pull-up resistor.
 0D5                            ;
 0D5  05F02         I2C_data_Z: OR sF, 02[I2C_data]               ;DATA = Z
 0D6  2DF08                     OUTPUT sF, 08[I2C_output_port]
 0D7  25000                     RETURN 
 0D8                            ;
 0D8                            ;
 0D8                            ; Receive one bit of data
 0D8                            ;
 0D8                            ; The bit received is shifted into the LSB of register 's5'.
 0D8                            ;
 0D8                            ; This the routine must be executed from the condition CLK low.
 0D8                            ;
 0D8                            ; The DATA line is released to allow a slave to transmit. There will be a
 0D8                            ; 5us delay before the CLK is released to start a clock pulse. The start of
 0D8                            ; the clock pulse can be delayed by a slave but a High duration of 4us is
 0D8                            ; guaranteed. The value of the DATA line is sampled at the mid-point of the
 0D8                            ; 4us high period (i.e. after 2us). The CLK clock pulse is followed by a
 0D8                            ; delay of 5us before anything else can happen.
 0D8                            ;
 0D8  200D5         I2C_Rx_bit: CALL 0D5[I2C_data_Z]              ;DATA = Z (slave can now drive)
 0D9  200E2                     CALL 0E2[I2C_delay_5us]
 0DA  200CC                     CALL 0CC[I2C_clk_Z]               ;CLK = Z (waits until definitely High)
 0DB  200E5                     CALL 0E5[I2C_delay_2us]           ;middle of SCL clock pulse
 0DC  09002                     INPUT s0, 02[I2C_input_port]      ;read external signals
 0DD  0D002                     TEST s0, 02[I2C_data]             ;set carry flag with value of DATA
 0DE  14500                     SLA s5                            ;shift received bit into LSB of s5
 0DF  200E5                     CALL 0E5[I2C_delay_2us]           ;complete 4us SCL clock pulse
 0E0  200C8                     CALL 0C8[I2C_clk_Low]             ;end of clock pulse includes 5us delay
 0E1  25000                     RETURN 
 0E2                            ;
 0E2                            ;
 0E2                            ; Software Delays for I2C Signal Timing
 0E2                            ;
 0E2  200E8      I2C_delay_5us: CALL 0E8[I2C_delay_1us]
 0E3  200E8      I2C_delay_4us: CALL 0E8[I2C_delay_1us]
 0E4  200E8                     CALL 0E8[I2C_delay_1us]
 0E5  200E8      I2C_delay_2us: CALL 0E8[I2C_delay_1us]
 0E6  200E8                     CALL 0E8[I2C_delay_1us]
 0E7  25000                     RETURN 
 0E8                            ;
 0E8                            ; The base delay is 1us and takes ((4 x I2C_time_reference) + 6) clock cycles
 0E8                            ; to execute including the CALL instruction required to invoke it.
 0E8                            ;
 0E8                            ; For example, if the clock frequency is 100MHz then 'I2C_time_reference' should be set
 0E8                            ; to 24'd. This will result in 24 iterations of the 'SUB' and 'JUMP NZ' loop resulting
 0E8                            ; in the execution of 48 instructions. The invoking 'CALL', the 'LOAD' and the 'RETURN'
 0E8                            ; bringing the total number of instructions to 51. All instructions take 2 clock cycles
 0E8                            ; to execute so that is a total of 102 clock cycles which take 1.02us at 100MHz.
 0E8                            ;  i.e. ((4 x I2C_time_reference) + 6) = ((4 x 24) + 6) = 102 clock cycles
 0E8                            ;
 0E8  01018      I2C_delay_1us: LOAD s0, 18[I2C_time_reference]
 0E9  19001     I2C_delay_loop: SUB s0, 01[1'd]
 0EA  360E9                     JUMP NZ, 0E9[I2C_delay_loop]
 0EB  25000                     RETURN 
 0EC                            ;
 0EC                            ;
 0EC                            ;------------------------------------------------------------------------------------------
 0EC                            ; End of 'i2c_routines.psm'
 0EC                            ;------------------------------------------------------------------------------------------
 0EC                            ;


All unused memory locations contain zero (equivalent to 'LOAD s0, s0')



List of PSM files that have been assembled

E:\I2C_Picoblaze\i2c_picoblaze\ad9984a_init.psm
E:\I2C_Picoblaze\i2c_picoblaze\soft_delays_100mhz.psm
E:\I2C_Picoblaze\i2c_picoblaze\i2c_routines.psm



List of defined constants

 CONSTANT name      Value        Source PSM File

 timestamp_hours    07'd         
 timestamp_minutes  03'd         
 timestamp_seconds  28'd         
 datestamp_year     14'd         
 datestamp_month    7'd          
 datestamp_day      31'd         
 NUL                00           
 BEL                07           
 BS                 08           
 HT                 09           
 LF                 0A           
 VT                 0B           
 CR                 0D           
 ESC                1B           
 DEL                7F           
 DCS                90           
 ST                 9C           
 I2C_time_reference 24'd         i2c_routines.psm
 I2C_input_port     02           i2c_routines.psm
 I2C_output_port    08           i2c_routines.psm
 I2C_clk            00000001'b   i2c_routines.psm
 I2C_data           00000010'b   i2c_routines.psm



No TABLEs defined



List of text strings

 STRING name       String         Source PSM File

 KCPSM6_version$   "v2.63"        
 datestamp$        "31 Jul 2014"  
 timestamp$        "07:03:28"     



List of line labels

   Label               Addr  Source PSM File

   forever             005   ad9984a_init.psm
   AD9984A_init        01A   ad9984a_init.psm
   i2c_write_AD9984A   07E   ad9984a_init.psm
 * delay_1ms           08B   soft_delays_100mhz.psm
   delay_20ms          08F   soft_delays_100mhz.psm
 * delay_1s            093   soft_delays_100mhz.psm
   software_delay      097   soft_delays_100mhz.psm
   I2C_initialise      09D   i2c_routines.psm
   I2C_start           0A1   i2c_routines.psm
   I2C_stop            0A8   i2c_routines.psm
   I2C_Tx_byte         0AE   i2c_routines.psm
   I2C_Tx_next_bit     0AF   i2c_routines.psm
   I2C_Tx1             0B3   i2c_routines.psm
   I2C_Tx_tsu          0B4   i2c_routines.psm
 * I2C_Rx_byte         0B8   i2c_routines.psm
   I2C_Rx_next_bit     0B9   i2c_routines.psm
 * I2C_Tx_ACK          0BD   i2c_routines.psm
   I2C_clk_pulse       0BE   i2c_routines.psm
 * I2C_Tx_NACK         0C3   i2c_routines.psm
   I2C_Rx_ACK          0C5   i2c_routines.psm
   I2C_clk_Low         0C8   i2c_routines.psm
   I2C_clk_Z           0CC   i2c_routines.psm
   I2C_wait_clk_High   0CE   i2c_routines.psm
   I2C_data_Low        0D2   i2c_routines.psm
   I2C_data_Z          0D5   i2c_routines.psm
   I2C_Rx_bit          0D8   i2c_routines.psm
   I2C_delay_5us       0E2   i2c_routines.psm
   I2C_delay_4us       0E3   i2c_routines.psm
   I2C_delay_2us       0E5   i2c_routines.psm
   I2C_delay_1us       0E8   i2c_routines.psm
   I2C_delay_loop      0E9   i2c_routines.psm

      * Line label has not been referenced in any instructions.
        Hint - This may indicate unused code that could be
               removed to reduce the size of this program.



Instruction usage statistics

 Instruction    Instances

 LOAD             96
 STAR              -

 AND               2
 OR                3
 XOR               -

 ADD               -
 ADDCY             -
 SUB               3
 SUBCY             2

 TEST              4
 TESTCY            -
 COMPARE           -
 COMPARECY         -

 SL0               1
 SL1               -
 SLX               -
 SLA               1
 RL                -
 SR0               1
 SR1               -
 SRX               -
 SRA               -
 RR                -

 REGBANK           -

 INPUT             2
 OUTPUT            5
 OUTPUTK           -

 STORE             -
 FETCH             -

 DISABLE           -
 ENABLE            -
 RETURNI           -

 JUMP             12
 JUMP@             -
 CALL             87
 CALL@             -
 RETURN           17
 LOAD&RETURN       -

 HWBUILD           -



End of KCPSM6 log file.
